
(priority ordered)

* Serialize und Deserialize fÃ¼r Tuple-Automaten

* (Human) Read / Write
	[general]
	is dfa=true
	alphabet size=4
	number of states=5
	[initial states]
	...
	[final states]
	...
	[transitions]
	q,l,q
	...

A)

- check undo and increase_alphabet_size() in angluin

- efficient L* algorithm (tree-like)

- RPNI algorithm

- documentation (?)

- create new network protocol (similar to JNI) to make switching between JNI and dispatcher easy

- check network/deserialization code for bugs (or make dispatcher obsolete => CK: der darf nicht obsolete werden, da wir das Ganze ja evtl auch auf einem Server laufen lassen wollen)

- implement `extend normalizer' in dispatcher and normalizer (CK: What is that)

- add (de)serialize to NL*

- add normalizer to NL*

- add undo to NL*

- check increase_alphabet_size() in NL*

B)

- efficient Bierman implementation (using DDB instead of MiniSat)

- BL* algorithm

- DeLeTe2

- check idea of assistants in knowledgebase (CK: Do you mean "filters" here?)
  [ problem: when algorithm works with pointers, either the non-normalized does not have
    a pointer or we need to add it each time something is requested. even for bottom... ]

- CPU/MEM stats for biermann

C)

- in AMoRE++: _init and _fini are not working (linker stuff...)

- check if template can be removed from learning_algorithm (CK: I think it must not be removed. For learning output automata you need more than only +,- (or 0,1))
  (thus all alg. are of class learning_algorithm<bool>)
  [ possibly not due to BL* ]

- knowledgebase also without undo/timestamps, to reduce memory footprint (CK: you mean optionally with or without undo?!)

- in learn_regex: check/fix '+' operator in regex on command-line

- enable dispatcher to listen on multiple address/port combinations, IPv6 and unix domain sockets


