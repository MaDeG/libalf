
PROTOCOL LAYOUT
===============

protocol is int32_t based in network byte order

server listens on socket.

client connects.

server forks and sends CAPA (like in "request server capabilities")

now server is waiting for client commands


CLIENT COMMANDS
===============

UNRELATED COMMANDS:
	disconnect
		client sends
			CM_DISCONNECT
		server answers
			CM_ACK_DISCONNECT
		server closes socket and dies.

	request server capabilities
		client sends
			CM_REQ_CAPA
		server answers
			SM_ACK_CAPA,
			protocol version (0 for this protocol)
			count,
			{
				capabilities[]
			} (count times)
	
	STARTTLS
		only applicable if server supports STARTTLS (see section CAPABILITIES)
		client sends
			CM_STARTTLS
		server answers
			SM_ACK_STARTTLS
		server switches to TLS mode

SESSION-RELATED COMMANDS:
	request session
		client sends
			CM_REQ_SESSION
			algorithm
			alphabet size (initial)
		server answers
			CM_ACK_SESSION,
			session id

	set modalities
		client sends
			CM_SES_SET_MODALITIES	
			session id
			count
			{
				modality
			} (count times)
		server answers
			SM_SES_ACK_MODALITIES

	request session-status
		client sends
			CM_SES_REQ_STATUS
			session id
		server answers
			SM_SES_ACK_REQ_STATUS
			status[]
	set session-status
		client sends
			CM_SES_SET_STATUS
			session id
			status[]
		server answers
			SM_SES_ACK_SET_STATUS
			bool ok (true if success, false otherwise)

	advance
		client sends
			CM_SES_ADVANCE
			session id
		server answers
			A)
				SM_SES_ACK_ADVANCE_AUTOMATA
				automaton[]
		or server answers
			B)
				SM_SES_ACK_ADVANCE_SQT
				structured query tree[]

	answer structured query tree
		client sends
			CM_SES_ANSWER_SQT
			session id
			answer for structured query tree[]
		server answers
			SM_SES_ACK_ANSWER_SQT
			bool ok (true if success, false otherwise)

	give counter-examples
		client sens
			CM_SES_GIVE_COUNTEREXAMPLES
			count
			{
				serialized word
			} (count times)
		server answers:
			SM_SES_ACK_COUNTEREXAMPLES

	request statistics
		client sends
			CM_SES_REQ_STATS
			session id
		server answers
			SM_SES_ACK_STATS
			statistics[]



DATA FIELDS
===========

enum client_message {
	CM_DISCONNECT = 0,

	CM_REQ_CAPA = 1,

	CM_STARTTLS = 10,

	CM_REQ_SESSION = 20,

	CM_SES_SET_MODALITIES = 21,

	CM_SES_REQ_STATUS = 22,
	CM_SES_SET_STATUS = 23,

	CM_SES_ADVANCE = 24,

	CM_SES_ANSWER_SQT = 25,

	CM_SES_GIVE_COUNTEREXAMPLES = 26,

	CM_SES_REQ_STATS = 30
}

// (enum client_message corresponds to dispatcher::client_message)

enum server_message {
	SM_ACK_DISCONNECT = 0,

	SM_ACK_CAPA = 1,

	SM_ACK_STATTLS = 10

	SM_ACK_SESSION = 20,

	SM_SES_ACK_MODALITIES = 21,

	SM_SES_ACK_REQ_STATUS = 22,
	SM_SES_ACK_SET_STATUS = 23,

	SM_SES_ACK_ADVANCE_AUTOMATA = 24,
	SM_SES_ACK_ADVANCE_SQT = 25,

	SM_SES_ACK_ANSWER_SQT = 25,
	
	SM_SES_ACK_COUNTEREXAMPLES = 26,

	SM_SES_ACK_STATS = 30
}

// (enum server_message corresponds to dispatcher::server_message)

enum algorithm {
	ALG_NONE = 0,
	ALG_ANGLUIN = 1,
	ALG_BIERMANN = 2
}

// (enum algorithm corresponds to enum libalf::learning_algorithm::algorithm)

int32_t capabilities [] {
	length of upcoming data (excluding this field)
	enum capability_type
	data []
}

enum capability_type {
	CAPA_STARTTLS = 0
}

// (enum capability_type corresponds to dispatcher::capability_type)

int32_t status [] {
	length of upcoming data (excluding this field)
	enum algorithm
	data []
} // you should just take the whole data as a blank structure
  // you save to disk and reload later on.

int32_t modality [] {
	length
	enum modality_type
	data[]
}

enum modality_type {
	MODALITY_TOTAL_ORDER_FUNC = 0
}

// (enum modality_type corresponds to enum dispatcher::modality_type)

int32_t automaton [] {
	length of upcoming data (excluding this field)
	alphabet size
	state count
	number of initial states
	initial states []
	number of final states
	final states []
	number of transitions
	{
		transition source
		transition label (-1 for epsilon)
		transition destination
	}
}

int32_t structured query tree [] {
	length of upcoming data (excluding this field)
	count
	{
		prefix enabled query
	} (count times)
}

int32_t prefix enabled query {
	length of upcoming data (excluding this field)
	serialized word[]
	prefix count
	acceptance count
	enum acceptance []
}

// note on structured query tree and prefix enabled queries:
// for now the SQT is a list of prefix-enabled queries. 
// a prefix-enabled query is a query for the acceptance of a word
// and some of its longest prefixes:
// an example:
//    prefix enabled query {
//		8			size
//		5 { .0.0.1.3.2. }	serialized word
//		2			prefix count
//		3			acceptance count
//		{ 4, 0, 2 }		acceptances
// this query asks for acceptances for the word .0.0.1.3.2. and
// two of its longest prefixes, i.e. .0.0.1.3. and .0.0.1.
// as a prefix-enabled query may contain answers (so that an
// just answered SQT may be serialized), acceptance count
// is the number of upcoming acceptances. the list of these
// acceptances (here 5,0,0) is matched to the words like this:
// the first acceptance belongs to the word itself, the next
// acceptance to the longest prefix, the acceptance after this
// to the second-longest prefix and so on. thus, in the above
// example, the word .0.0.1.3.2. is accepted, its prefix
// .0.0.1.3. is not accepted and the acceptance for .0.0.1.
// is unknown.

enum acceptance {
	ACCEPTANCE_FALSE		= 0,
	ACCEPTANCE_UNKNOWN		= 1,
	ACCEPTANCE_TRUE			= 2
}

// (enum acceptance corresponds to a serialized libalf::extended_bool)

int32_t answer for structured query tree [] {
	length of upcoming data (excluding this field)
	enum acceptance[]
}

// note on answer for structured query tree:
// the answers have to correspond do the last SQT received from
// the server: for each member in the SQT, the acceptances for
// the word and its prefixes are concatenated. the resulting
// string of acceptances is prefixed by its length and sent
// like above.

int32_t statistics [] {
	length of upcoming data (excluding this field)
	table size: bytes
	table size: members
	table size: words
	membership query count
	equivalence query count
}

notes on total order function:
to disable the total order function after having set it, just set
a new total order function of length zero.

int32_t serialized word [] {
	length
	data[]
}

