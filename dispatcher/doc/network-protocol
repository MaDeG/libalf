
PROTOCOL LAYOUT
===============

protocol is int32_t based in network byte order

server listens on socket.

client connects.

server forks and sends CAPA (like in "request server capabilities")

now server is waiting for client commands


CLIENT COMMANDS
===============

UNRELATED COMMANDS:
	disconnect
		client sends
			CM_DISCONNECT
		server answers
			CM_ACK_DISCONNECT
		server closes socket and dies.

	request server capabilities
		client sends
			CM_REQ_CAPA
		server answers
			SM_ACK_CAPA,
			protocol version (0 for this protocol)
			count,
			{
				capabilities[]
			} (count times)

	STARTTLS
		only applicable if server supports STARTTLS (see section CAPABILITIES)
		client sends
			CM_STARTTLS
		server answers
			SM_ACK_STARTTLS
		server switches to TLS mode

SESSION-RELATED COMMANDS:
	request session
		client sends
			CM_REQ_SESSION
			algorithm
			alphabet size (initial)
		server answers
			SM_ACK_SESSION,
			session id

	set modalities
		client sends
			CM_SES_SET_MODALITIES	
			session id
			count
			{
				modality
			} (count times)
		server answers
			SM_SES_ACK_MODALITIES
			bool ok (true if success, false otherwise)

	request session-status
		client sends
			CM_SES_REQ_STATUS
			session id
		server answers
			SM_SES_ACK_REQ_STATUS
			status[]
	set session-status
		client sends
			CM_SES_SET_STATUS
			session id
			status[]

		server answers
			SM_SES_ACK_SET_STATUS
			bool ok (true if success, false otherwise)

	conjecture (true, if a hypothesis can be resolved from current state)
		client sends
			CM_SES_CONJECTURE
			session id
		server answers
			SM_SES_CONJECTURE
			bool

	advance
		client sends
			CM_SES_ADVANCE
			session id
		server answers
			A)
				SM_SES_ACK_ADVANCE_AUTOMATON
				automaton[]
		or server answers
			B)
				SM_SES_ACK_ADVANCE_SQT
				structured query tree[]

	answer structured query tree
		client sends
			CM_SES_ANSWER_SQT
			session id
			answer for structured query tree[]
		server answers
			SM_SES_ACK_ANSWER_SQT
			bool ok (true if success, false otherwise)

	give counter-examples
		client sends
			CM_SES_GIVE_COUNTEREXAMPLES
			session id
			count
			{
				serialized word[]
			} (count times)
		server answers:
			SM_SES_ACK_COUNTEREXAMPLES
			bool ok (true if success, false otherwise)

	give counter-examples including their answers
		client sends
			CM_SES_GIVE_COUNTEREXAMPLES_AND_ANSWERS
			session id
			count
			{
				serialized word[]
				answer
			} (count times)
		server answers:
			SM_SES_ACK_COUNTEREXAMPLES_AND_ANSWERS
			bool ok (true if success, false otherwise)

	get current alphabet size
		client sends
			CM_SES_REQ_ALPHABET_SIZE
			session id
		server answers
			SM_SES_ACK_ALPHABET_SIZE
			alphabet size

	set alphabet size (if new size is <= old size, old size will remain)
		client sends
			CM_SES_SET_ALPHABET_SIZE
			session id
			new size
		server answers
			SM_SES_ACK_SET_ALPHABET_SIZE

	inc alphabet size
		client sends
			CM_SES_INC_ALPHABET_SIZE
			session id
			count by how much to increase alphabet
		server answers
			SM_SES_ACK_INC_ALPHABET_SIZE

	request statistics
		client sends
			CM_SES_REQ_STATS
			session id
		server answers
			SM_SES_ACK_REQ_STATS
			statistics[]

	set statistics
		client sends
			CM_SES_SET_STATS
			session id
			statistics[]
		server answers
			SM_SES_ACK_SET_STATS

	receive and flush log
		client sends
			CM_SES_REQ_LOG
			session id
		server answers
			SM_SES_ACK_LOG
			int length (in bytes!)
			text[]

	debugging commands:

	request table to be logged to logger (note loglevel LOGGER_DEBUG)
		client sends
			CM_SES_LOG_TABLE
			session id
		server answers
			SM_SES_ACK_LOG_TABLE

	normalize word with sessions current normalizer
		client sends
			CM_SES_NORMALIZE_WORD
			session id (for choice of normalizer)
			bool prefix normal form (set to false for suffix normal form)
			serialized word[]
		server answers
			SM_SES_ACK_NORMALIZE_WORD
			bool bottom
			serialized word[] (may be obscure if bottom = true)




DATA FIELDS
===========

enum client_message {
	CM_DISCONNECT = 0,

	CM_REQ_CAPA = 1,

	CM_STARTTLS = 10,

	CM_REQ_SESSION = 20,

	CM_SES_SET_MODALITIES = 21,

	CM_SES_REQ_STATUS = 22,
	CM_SES_SET_STATUS = 23,

	CM_SES_CONJECTURE = 24,

	CM_SES_ADVANCE = 25,

	CM_SES_ANSWER_SQT = 27,

	CM_SES_GIVE_COUNTEREXAMPLES = 28,
	CM_SES_GIVE_COUNTEREXAMPLES_AND_ANSWERS = 29,

	CM_SES_REQ_ALPHABET_SIZE = 30,

	CM_SES_SET_ALPHABET_SIZE = 31,

	CM_SES_INC_ALPHABET_SIZE = 32,

	CM_SES_REQ_STATS = 33,
	CM_SES_SET_STATS = 34,

	CM_SES_REQ_LOG = 35,

	CM_SES_LOG_TABLE = 100,
	CM_SES_NORMALIZE_WORD = 101
}

// (enum client_message corresponds to dispatcher::client_message)

enum server_message {
	SM_ACK_DISCONNECT = 0,

	SM_ACK_CAPA = 1,

	SM_ACK_STATTLS = 10

	SM_ACK_SESSION = 20,

	SM_SES_ACK_MODALITIES = 21,

	SM_SES_ACK_REQ_STATUS = 22,
	SM_SES_ACK_SET_STATUS = 23,

	SM_SES_CONJECTURE = 24,

	SM_SES_ACK_ADVANCE_AUTOMATON = 25,
	SM_SES_ACK_ADVANCE_SQT = 26,

	SM_SES_ACK_ANSWER_SQT = 27,
	
	SM_SES_ACK_COUNTEREXAMPLES = 28,
	SM_SES_ACK_COUNTEREXAMPLES_AND_ANSWERS = 29,

	SM_SES_ACK_ALPHABET_SIZE = 30,

	SM_SES_ACK_SET_ALPHABET_SIZE = 31,

	SM_SES_ACK_INC_ALPHABET_SIZE = 32,

	SM_SES_ACK_REQ_STATS = 33,
	SM_SES_ACK_SET_STATS = 34,

	SM_SES_ACK_LOG = 35,

	SM_SES_ACK_LOG_TABLE = 100,
	SM_SES_ACK_NORMALIZE_WORD = 101
}

// (enum server_message corresponds to dispatcher::server_message)

enum algorithm {
	ALG_NONE = 0,
	ALG_ANGLUIN = 1,
	ALG_BIERMANN = 2
}

// (enum algorithm corresponds to enum libalf::learning_algorithm::algorithm)

int32_t capabilities [] {
	length of upcoming data (excluding this field)
	enum capability_type
	data []
}

enum capability_type {
	CAPA_STARTTLS = 0
}

// (enum capability_type corresponds to dispatcher::capability_type)

int32_t status [] {
	length of upcoming data (excluding this field)
	enum algorithm
	data []
} // you should just take the whole data as a blank structure
  // you save to disk and reload later on. the total order is not included,
  // you will need to set these again (via modality)

int32_t modality [] {
	length (exluding this field, including type field)
	enum modality_type
	data[]
}

enum modality_type {
	MODALITY_SET_NORMALIZER = 0,
	MODALITY_EXTEND_NORMALIZER = 1,
	MODALITY_SET_LOGLEVEL = 2,
	MODALITY_SET_LOG_ALGORITHM = 3
}

// (enum modality_type corresponds to enum dispatcher::modality_type)

// for MODALITY_SET_NORMALIZER, the data consists of:

int32_t normalizer[] {
	length of upcoming data
	enum normalizer_type
	serialized normalizer
}

// where (corresponding to libalf::normalizer::type)

enum normalizer_type {
	NORMALIZER_NONE = 0,
	NORMALIZER_MSC = 1
}

// and for serialized normalizer one of:

serialized NORMALIZER_NONE {
	// nothing
}

to disable the total order function after having set it, just set
a new total order function of type NORAMLIZER_NONE and length zero.

serialized NORAMLIZER_MSC {
	length of total order
	total order
	length of message-process-matching
	message-process-matching
	length of message-buffer-matching
	message-buffer-matching
	max buffer length
}

// the MSC normalizer consists of 4 distinct fields:
// the total order, the message-process matching relation, the
// message-buffer matching relation and the maximal buffer size.

// the total order is a function mapping each symbol of the alphabet
// to its position in a total order. thus to get the ordered position
// of a label l, we use total_order[l].
// furthermore the total order implies the following:
// for every label n, if total_order[n]%2==0 then it is a send-event and 
// there exists a message m with total_order[m] = total_order[n]+1,
// total_order[m]%2==1 that is the corresponding receive event of the
// receiving process (thus total_order[n] / 2 == total_order[m] / 2)
//
// the message-process matching (MPM) relation matches an event (or label) l
// to its corresponding sending process MPM[l]
//
// the message-buffer-matching (MBM) relation matches an event (or label) l
// to a buffer MBM[l] corresponding to the tuple (sender, receiver)
// 
// the max buffer size denotes how many messages there may be at most at
// any time in a single buffer. this number increases once a sent-event
// has happened and decreases once a receive-event has happened.
// use any number <= 0 to denote infinite buffers.
// 


// for MODALITY_EXTEND_NORMALIZER, the data consists of:

int32_t normalizer_extension[] {
	length of upcoming data

	FIXME

}

// for MODALITY_SET_LOGLEVEL, the data consists of a single int of
// type enum logger_loglevel:

enum logger_loglevel {
	LOGGER_ERROR = 1;
	LOGGER_WARN = 2;
	LOGGER_INFO = 3;
	LOGGER_DEBUG = 4;
}
(enum logger_loglevel corresponds to enum libalf::logger_loglevel)

// for MODALITY_SET_LOG_ALGORITHM, the data consists of a single int.
// if this int is 0 (false), algorithm logging is disabled. otherwise
// (true), it is enabled.



int32_t automaton [] {
	length of upcoming data (excluding this field)
	alphabet size
	state count
	number of initial states
	initial states []
	number of final states
	final states []
	number of transitions
	{
		transition source
		transition label (-1 for epsilon)
		transition destination
	}
}

int32_t structured query tree [] {
	length of upcoming data (excluding this field)
	count
	{
		prefix enabled query
	} (count times)
}

int32_t prefix enabled query {
	length of upcoming data (excluding this field)
	prefix count
	serialized word[]
	acceptance count
	enum acceptance []
}

// note on structured query tree and prefix enabled queries:
// for now the SQT is a list of prefix-enabled queries. 
// a prefix-enabled query is a query for the acceptance of a word
// and some of its longest prefixes:
// an example:
//    prefix enabled query {
//		8			size
//		5 { .0.0.1.3.2. }	serialized word
//		2			prefix count
//		3			acceptance count
//		{ 4, 0, 2 }		acceptances
// this query asks for acceptances for the word .0.0.1.3.2. and
// two of its longest prefixes, i.e. .0.0.1.3. and .0.0.1.
// as a prefix-enabled query may contain answers (so that an
// just answered SQT may be serialized), acceptance count
// is the number of upcoming acceptances. the list of these
// acceptances (here 5,0,0) is matched to the words like this:
// the first acceptance belongs to the word itself, the next
// acceptance to the longest prefix, the acceptance after this
// to the second-longest prefix and so on. thus, in the above
// example, the word .0.0.1.3.2. is accepted, its prefix
// .0.0.1.3. is not accepted and the acceptance for .0.0.1.
// is unknown.

enum acceptance {
	ACCEPTANCE_FALSE		= 0,
	ACCEPTANCE_UNKNOWN		= 1,
	ACCEPTANCE_TRUE			= 2
}

// (enum acceptance corresponds to a serialized libalf::extended_bool)

int32_t answer for structured query tree [] {
	length of upcoming data (excluding this field)
	enum acceptance[]
}

// note on answer for structured query tree:
// the answers have to correspond do the last SQT received from
// the server: for each member in the SQT, the acceptances for
// the word and its prefixes are concatenated. the resulting
// string of acceptances is prefixed by its length and sent
// like above.

int32_t statistics [] {
	length of upcoming data (excluding this field)
	table size: bytes
	table size: members
	table size: words
	table size: upper table
	table size: lower table
	table size: columns
	membership query count
	equivalence query count
}

int32_t serialized word [] {
	length
	data[]
}

