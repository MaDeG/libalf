\chapter{The Knowledgebase}

The knowledgebase is the central repository of information. It is a database that stores words and their classification. Apart from this basic functionality, the knowledgebase also offers number of other features thereby increasing the support for extensibility.
These features are reflected in the implementation of the knowledgebase. The methods used in the knowledgebase can be divided into two categories - \textbf{\emph{Methods important for Using \libalf}} and \textbf{\emph{Methods important for expanding \libalf}}. 
\paragraph{}
The chapter discusses these methods from both a user's perspective and a developer's perspective. The material will include adequate account of its structure, operations and implementation.  The final section of this chapter will provide an appendix of all the methods used in programming the knowledgebase with a brief description that corresponds to it.  
\vskip 1pt

\section{The knowledgebase - A User's Perspective}

\paragraph{} In this section, we describe the basic functionality of the knowledgebase and provide fundamental information that one would have to know to employ \libalf in an application. It will explicate functional practice of the database and some elementary details of methods to better understand how the operations are carried out. This section will not deal with elaboration of the internal structure or methods that can be used to extend the knowledgebase. To discover more about it, you may refer the section on Developer's Perspective and Methods in Detail.

\subsection*{Basic Concepts}
	
	The definition of some important underlying concepts allows understanding \libalf and the knowledgebase at a better scale. Some of the key terms include the following.

\paragraph{Alphabet} An alphabet is a finite set of symbols which is usually denoted by $\Sigma$. Symbols could be numbers (0,1,\ldots) or alphabets(a,b,\ldots) and so on. \libalf uses an integers to represent the symbols as expressed below.
\vskip 1pt
\[
\sum = \{0,1,\ldots\}
\]

\textbf{Alphabet Size} defines the largest symbol used in the conjecture. Thus, when alphabet size of two is specified by the user, \libalf will use the following symbols. 
\[
\sum = \{0,1\}
\]

This implies, that an alphabet size of two will result in the largest symbol being ``1''.

\paragraph{Word} A word (w$\in$$\Sigma$*) is finite string formed by the concatenation of the symbols from $\Sigma$. Since the symbols used in \libalf are of type \integer, the words are operated as a \texttt{list} of \integer.  

\paragraph{Language} Language is a set of words formed by symbols, given the alphabet.

Thus, in the context of the previous example, ``01101'' would be a word from the given set of alphabet and the set \{ 01101, 11011\} would be a Language.

\subsection*{Working with Words} 
The knowledgebase of \libalf is an efficient storage of words and their classifications. Classification refers to the acceptance rule of a word i.e., whether the word has to be accepted or rejected by the conjecture. An issue here would be how to represent this classification. For instance, \true and \false could be one of the means to express the acceptance rule. Some other application would require usage of ``0'' and ``1'' to distinguish the words. \libalf can effectively handles the situation as it uses template class for the knowledgebase by that allowing arbitrary values for storage of the information. Internally, the knowledgebase collects this information under the variable \texttt{status}. 

\subsection*{Queries and Answers} 
The next important function of the knowledgebase is to store queries to help the learning algorithm build the automaton. As mentioned in the previous chapter, a query is a word whose classification is unknown and needs to be retrieved from the user or teacher. In other words, the query must be \emph{resolved} by the user. To resolve the query, user provides what is called an \emph{answer}. Thus, given a set of words and classifications, the knowledgebase stores them and when a learning algorithm processes these words to create the conjecture, queries that occur are also stored in the knowledgebase (which is later presented to the user for an answer).

\subsection*{Other features} 
Apart from the essential functions, the knowledgebase also provides certain features that can be made us of when employing it in an application. The knowledge available in the knowledgebase can be also be serialized into the user's hard disk. Also, the knolwedgebase allows one to generate a ``.dot'' file of the knowledge available to have a graphical representation of the same. Furthermore, the knowledgebase can also be merged with another knowledgebase without introducing any errors. These features are elaborated in forthcoming sections.

\subsection{Methods in Detail}
	The section will describe some of the methods to support understanding how the knowledgebase works and how it could be employed in an application. The two important classes that build the knowledgebase are \knowledgebase and \node. The methods commonly used are as follows.
	
\subsection*{Creating the Knowledgebase}

	The knowledgebase is created by creating a root. The properties to this root are set by the class \node.
\begin{itemize}
\item \textbf{node::node(knowledgebase * base)} \vskip 1pt
	The constructor of the class \node creates the root node of the knowledgebase with the following values.
	\begin{enumerate}
	\item parent = NULL ; root node does not have a parent.
	\item label = -1 ; which is equivalent to epsilon
	\item status = STATUS\_IGNORE ; the acceptance rule or classification of the root node is initially not necessary.
	\end{enumerate}	
\end{itemize}
	
\subsection*{Adding Knowledge to the Knowledgebase} 

\begin{itemize}
\item \textbf{knowledgebase::bool add\_knowledge(list$<$int$>$ \& word, answer acceptance)} \vskip 1pt
	This is the key method that adds words and classifications to the knowledgebase. The parameter ``word'' represents the sample word and ``acceptance'' represents the classification of the word. 
\end{itemize}	

\subsection*{Handling Queries}
	The next point of discussion would be the part of knowledgebase that handles queries. When an online algorithm produces queries at every ``advance'' of the algorithm, they are stored in the knowledgebase and presented to the user for classification. To perform these operations, a learning algorithm would make use of the following two important methods.

\begin{enumerate}
\item \textbf{knowledgebase::knowledgebase * create\_query\_tree()} \vskip 1pt
	The method creates a tree containing the queries to be answered. Thus, Its return type is set as \texttt{knowledgebase}.
	
\item \textbf{knowledgebase::list$<$list$<$int$>$$>$ get\_queries()} \vskip 1pt
	This method returns the list of all the queries present in the knowledgebase (following the concept that all queries are marked as \texttt{NODE\_REQUIRED}). 
\end{enumerate}

\subsection*{Alphabets in Knowledgebase}
	At any point of time, one can retrieve the largest symbol being processed in the knowledgebase using the following method.
\begin{itemize}
\item \textbf{knowledgebase::int get\_largest\_symbol()} \vskip 1pt 
	This method returns the largest symbol that exists in the knowledgebase. This is stored in a variable called ``largest\_symbol''. Since \libalf employs the usage of integers for storage of symbols, the result is not the size of the alphabet but one less than the alphabet size.
\end{itemize}	

\subsection*{Iterators}

	The knowledgebase uses the \lists of \integer to store the words. Subsequently, a \lists of \lists of \integer many words in a sequence (such as list of queries). To iterate over these lists and process the words, we require the starting and ending point. This is made possible by the following four methods.
\begin{enumerate}
\item \textbf{knowledgebase::iterator begin()} \vskip 1pt
	The method always returns the root node of the tree (epsilon).

\item \textbf{knowledgebase::iterator end()} \vskip 1pt
	The method returns the end of the word or in other words, the end node. 
	 
\item \textbf{knowledgebase::iterator qbegin()} \vskip 1pt
	This is the method used to get the query node at which the iterator needs to begin. That is, it begins at the first node which is marked as ``required''.
	
\item \textbf{knowledgebase::iterator qend()} \vskip 1pt
	It returns the final node which is a query.
\end{enumerate}

\subsection*{Displaying the knowledgebase}
The following two methods could be useful in ways to display the knowledgebase.

\begin{enumerate}

\item \textbf{knowledgebase::string tostring()} \vskip 1pt
It creates the \stringtype stream to be used by the ``print'' method.

\item \textbf{knowledgebase::string generate\_dotfile()} \vskip 1pt
	The method creates a ``.dot'' file of the entire knowledgebase. This is the method which was made use of in the demo programs explained int he previous chapter. The file can be executed with the GraphViz tool to observe the graphical representation of the knowledgebase. 
\end {enumerate}

\subsection*{Serialize and Deserialize}
	The cability to serialize and deserialize could prove very useful when working with \libalf. The description of these two methods and their purpose is given below.
	
\begin{enumerate}
\item \textbf{knowledgebase::basic\_string$<$int32\_t$>$ serialize()} \hfill \vskip 1pt
	This method is used to convert the entire knowledgebase into a \stringtype. 
\item \textbf{knowledgebase::bool deserialize(basic\_string$<$int32\_t$>$::iterator \&it, basic\_string$<$int32\_t$>$ ::iterator limit)} \hfill \vskip 1pt
	This method is used to convert the \stringtype that represents the knowledgebase into a tree-like structure.
\end{enumerate}	
	The main advantages of using these methods is that it offers portability. They allow the user to save their current work done with \libalf. By converting the tree into a single string, it allows the user to save the knowledgebase into the hard disk, share it over the internet, carry and use it another machine and so on. The deserialize method helps in converting back to the tree structure to put the \libalf into use.

\subsection*{Other Important Methods}
	The following methods offer features which may prove useful in using as well as extending \libalf.
\begin{enumerate}
\item \textbf{unsigned long long int get\_memory\_usage()} \vskip 1pt
	The method returns the memory used by the knowledgebase on the system. Using this method at some point could be a good way of deciding if cleanup() needs to be called or not. 
		
\item \textbf{bool merge\_knowledgebase(knowledgebase \& other\_tree)} \vskip 1pt
	This method is used to merge two different knowledgebases. In merging the same, it follows some protocols. In the first place, two knowledgebases can be merged only if they are consistant, i.e., if they have similar words and answers. If inconsistant, the method returns \false. Otherwise, the method moves on to merge them. However, the method merges only all the answered nodes from the two knolwedgebases. Queries do not get merged. 

\item \textbf{bool recursive\_different(node * other, int depth)} \vskip 1pt
	The method is used to check the consistancy of two words. Two words are said to be consistant if they have the same answer. 
\end{enumerate}



\section{Structure of the Knowledgbase - A Developer Perspective}
	The structure of the knowledgebase is designed based on the decision on the data structure used for words. This increases the flexibility and expandability of \libalf. The two divisions below describe the design.

\subsection{Representation of a word in the Knowledgebase}
\paragraph{}
	Ideally, the first step towards understanding the organization of the knowledgebase would be to realize how a word is represented in it.
\paragraph{}
	Generally, the knowledgebase can be described as a tree structure with nodes representing the words. More precisely, it is a prefix tree. Given this description and the demo programs from the website (which even presents a graphical representation of the tree), one would imagine a word \texttt{01101} in the knowledgebase as a tree with a node that holding a \stringtype or \texttt{list of integers} with value ``01101''. However, this is \textbf{NOT} how knowledgebase is implemented in \libalf.
\paragraph{}
	The node by itself does \emph{not} contain the complete word, but only contains the i\textsuperscript{th} symbol of the word. Consider the example given below. \vskip 1pt
	
		(A PICTURE OF THE ABOVE EXPLAINED TREE HERE)
		
\paragraph{}	
	Consider the word \texttt{01101}. When this word is added to the knowledgebase, it is not stored as a single \stringtype at a node of the tree, instead the sequence of the symbols that comprise the word construct the branch of the tree with every node representing exactly one symbol. This implies, to represent this word in the knowledgebase, the root (which is always an empty string represented by Epsilon) creates a child node that represtents ``0''. The next symbole of the word ``1'' is now represented in a node which is the child of the node representing its previous symbol ( or the parent node), ``0''. Thus, one can reach the node representing the word \texttt{01101} by following the 0\textsuperscript{th} child of the root node, then further accessing the first child of this node and so on.
\paragraph{}
	Hence, to retrive a word from the tree, one has to traverse down from the root node to the final child node by accumulating the symbols that every node represents. Alternatively, one can also recover the word by ascending from a node to the root and reversing the word obtained. \libalf uses the latter technique. 
	\vskip 1pt
	
\subsection{Description of the Structure}
	
	The knowledgebase is designed as a template class enabling usage of arbitrary values for storing desired information.
	The knowledgebase class contains the node class which describes the variables that are necessary for the node. This class also contains some of the internal methods which are important for both using and expanding \libalf.
	The constructor of the node class creates the tree, more precisely (a root node) with the following variables that define the node.
	\begin{itemize}
	\item \texttt{parent} \hfill \vskip 1pt A variable of type \node that points to the parent of the node.
	\item \texttt{label} \hfill \vskip 1pt An \integer variable that contains the alphabet that the node represents. 
	\item \texttt{status} \hfill \vskip 1pt This indicates whether the classification of the word (the word is constructed by traversing through the tree) is required, answered or can be ignored. Since the knowledgebase is a prefix tree, it contains not only the supplied words but also stores the prefixes of the word. However, the status of these prefixes may not be of interest and can be \emph{ignored}. On the otherhand when the learning algorithm creates more words, it stores them into the knowledgebase for presenting it to the user. Classification to such words are \emph{required}. Thus, the variable differentiates these words. For this purpose, it is an \texttt{enum} type variable that can take one of three values ``NODE\_IGNORE'', ``NODE\_REQUIRED'' and ``NODE\_ANSWERED''. 
	\item \texttt{ans} \hfill \vskip 1pt The variable stores the answer (or the acceptance criteria / classification) of the node. 
	\end{itemize}
	
	The child nodes that are created after this are referred by the \vectored type \node variable called \texttt{children}. 
	The knowledgebase contains methods that act upon the node for the operations. 
	These variables and methods form the building blocks of the knowledgebase. Some of the methods are described in the next section.

\subsection{Methods in Detail}
	Having described the methods important for using \libalf in the previous section on user's perspective, this section provides description of few more methods that are useful for extending \libalf. The section will mostly contain the operations that can be performed over the node, methods on handling words, classifications and queries. Nevertheless, a complete list of methods and their explanation is given in the next section.
	
\subsection*{Working with Nodes}
	Methods operating on the nodes are mostly internal methods and cannot be accessed publicly.
\begin{enumerate}
\item \textbf{node::node* get\_next(node * current\_child)} \vskip 1pt
	This function returns the next node or the next child of the current node (which is passed as an arguement). 
	
\item \textbf{node::node * get\_parent()} \vskip 1pt
	The method returns the parent of the node under use.

\item \textbf{node::list$<$int$>$ get\_word()} \vskip 1pt
	This function returns the word that the current node represents. The method traverses backwards in the tree (ascending from child to parent) and reverses the sequence obtained to build the correct word.
	
\item \textbf{node::int get\_label()} \hfill \vskip 1pt
	This function returns the label that the node represents.
	
\item \textbf{node::node * find\_child(int label)} \hfill \vskip 1pt
	The function is used to find the child node with the specified label.
	
\item \textbf{node::node * find\_descendant(list$<$int$>$ :: iterator infix\_start, list<int>::iterator infix\_limit)} \hfill \vskip 1pt
	This function is used to find the child node specified by a word and returns the node. It traverses through the tree based on the iteration over the word to find the path that generates the required word.
	
\item \textbf{knowledgebase::node* get\_rootptr()} \hfill \vskip 1pt
	The function returns the pointer to the root node of the knowledgebase.
	
\item \textbf{knowledgebase::node* get\_nodeptr(list$<$int$>$ \& word)} \hfill \vskip 1pt
	This function returns the pointer to the current node specified by the word as the parameter.
	
\end{enumerate}

\subsection*{Words and Classification}

	In principal, the primary focus of the knowledgebase is centered on storing words and classifications which constitutes the base for the learning algorithm to compute a conjecture. Methods related to this aspect are discussed below.
	
\begin{enumerate}
\item \textbf{node::node * find\_or\_create\_child(int label)} \vskip 1pt
	This function returns the child node given the label. However, if the node does not exist, it creates the child node with the specified label.
	
\item \textbf{node::node * find\_or\_create\_descendant(list$<$int$>$::iterator infix\_start, list$<$int$>$::iterator infix\_limit)} \hfill \vskip 1pt
	This function behaves almost similar to the previous one. However, the difference being, it does not operate with a single label but on a word (which is a list of \integer). 
\end{enumerate}	

 In fact, the method \texttt{add\_knowledge} simply calls the method \texttt{find\_or\_create\_descendant} so that the knowledge will be added only information about the word does not already exist in the knowledgebase.


\subsection*{Handling Queries}
	Although some of the query handling methods have already been discussed, a few other important methods of interest are explained below. As mentioned previously, query handling depends more on the ``status'' of the word. This directly implies the \texttt{status} variable of the node. Operations made in regard to this is first described below.
\begin{enumerate}
\item \textbf{bool mark\_required()} \vskip 1pt
	The method returns a boolean value \true if the acceptance or the classification of the node is requried (i.e, ``status'' is NODE\_REQUIRED) or \false if the classification is already known.
	
\item \textbf{bool is\_required()} \vskip 1pt
	The method returns the ``status'' as \texttt{NODE\_REQUIRED}. It is used to set this status to a particular node under consideration.

\item \textbf{bool is\_answered()} \vskip 1pt
	The method returns the ``status'' as \texttt{NODE\_ANSWERED}. It is used to set this status to a particular node under consideration.
	
\item \textbf{answer get\_answer()} \vskip 1pt
	The method returns the answer (classification of the node) stored for the node. 
\end{enumerate}

\vskip 1pt
  The following methods describe the operations associated with queries.

\begin{enumerate}

\item \textbf{int add\_query(list$<$int$>$ \& word, int prefix\_count = 0)} \hfill \vskip 1pt
	The method is primarily used to add a query to the knowledgebase. When the classification of a word has to be known, the method first checks if the word already exists with its classification in the knowledgebase (by using the \texttt{find\_or\_create\_child(int label)} method). Hence, if the classification of the word is unknown and does not already exist, the corresponding node will be created and eventually added in the query tree (since this method is used by \texttt{create\_query\_tree(\ldots)}.
  	
\item \textbf{bool resolve\_query(list$<$int$>$ \& word, answer \& acceptance) and bool resolve\_or\_add\_query(list$<$int$>$ \& word, answer \& acceptance)} \hfill \vskip 1pt
	These two methods can be described together as their functionality is almost similar and differ only in one aspect. Both methods return \true if the classification of the word is already known and \false if it is unknown. While ``resolve\_query()'' only returns \false, ``resolve\_or\_add\_query()'' marks the status of this word as required and then returns \false. Naturally, the former uses ``find\_descendant()'' and the latter makes use of ``find\_or\_create\_descendant()''.

\item \textbf{void clear\_queries()} \hfill \vskip 1pt
	This method is used to remove all the nodes that are identified or marked as a query.
\end{enumerate}
\vskip 1pt
\vskip 1pt

\subsection*{Alphabets in Knowledgebase}
	This section gives an extended view of the concept of alphabet size in the knowledgebase. Although we have defined the basic concepts of alphabets in this chapter, the knowledgebase does not really store the alphabet size of the automaton specified by the user. The knowledgebase does not construt the tree based on the alphabet size specified by the user and is capable of constructing the tree precisely even if symbols outside the alphabet set are fed in the input (which includes the extra symbols). But, such improper input will lead to the learning algorithm computing a conjecture which might not be the expectation of the user.
	However, the knowledgebase can at any point of time identify and operate on the alphabet size. This can be regarded as the largest symbol that is processed in the knowledgebase. Reiterating the fact mentioned already, that an alphabet size of 2 would contain ``1'' as the largest symbol, we discuss the following methods that work on the issue.
\begin{enumerate}
\item \textbf{int get\_largest\_symbol()} \hfill \vskip 1pt
	This is already described in the section on user's perspective. But some secondary information about this would be the fact that the method directly returns what is available in the variable ``largest\_symbol''. It does not check whether the alphabet size has been modified. A good way to do that would be to use the methods listed below.
	
\item \textbf{int check\_largest\_symbol()} \hfill \vskip 1pt
	The method performs a check on the knowledgebase and realizes the largest symbol that is currently available. Hence, if there was a change in the size of the alphabet at some point of time, it is automatacially adjusted when this method is called.
	
\item \textbf{bool cleanup()} \hfill \vskip 1pt
	This method is used to clean the knowledgebase by removing all the unnecessary branches i.e, branches that consists only of IGNORE as the status. This is an example for a method that can cause a change in the largest symbol. If only the branches contain a particular symbol and they are removed in the clean up, it subsequentely causes a change in the largest symbol. 
\end{enumerate}

\subsection*{Displaying the knowledgebase}
	Having described two methods in the previous section on the same topic, what is listed below is one other method which could be useful from the eye of a developer. \vskip 2pt
\textbf{void print(ostream \&os)} \vskip 1pt
	This method prints the knowledgbase to any kind of an output stream. It prints the word, its status and the answer of all the words available in the knowledgebase.
\vskip 1pt
These methods described would summerize the most important methods from the view of a developer.

	
\section{Methods Specifications}
The section supplies a comprehensive list of all the methods used in the knowledgebase along account of their particulars. The section is divided based on on the class that the methods belong to.
\subsection{Class - \node}
\begin{enumerate}
%%%
\item \begin{detail}
{get\_next}
{node* get\_next(node * current\_child)}
{current\_child - The current child}
{Returns the next node} 
\end{detail}
%%%
\item \begin{detail}
{Constructor}
{node(knowledgebase * base)}
{base - the name of the knowledgebase}
{Creates the root node of the knowledgebase and sets its \texttt{parent} to NULL} 
\end{detail}
%%%
\item \begin{detail}
{get\_parent}
{node * get\_parent()}
{--}
{Returns the parent of the node that calls this function} 
\end{detail}
%%%
\item \begin{detail}
{find\_child}
{node * find\_child(int label)}
{label - the label that the child node must contain}
{Returns the node that contains the label specified as the parameter} 
\end{detail}
%%%
\item \begin{detail}
{find\_descendant}
{node * find\_descendant(list$<$int$>$::iterator infix\_start,\\ list$<$int$>$::iterator infix\_limit)}
{infix\_start - the word or symbol that is the starting point \\ infix\_limit - the word which is to be found}
{Returns the node that represents the word infix\_limit} 
\end{detail}
%%%
\item \begin{detail}
{find\_or\_create\_child}
{node * find\_or\_create\_child(int label)}
{label - the label that the child node must contain}
{Returns the node that contains the label specified as parameter. If not found, it creates such a node and returns it.} 
\end{detail}
%%%
\item \begin{detail}
{serialize\_subtree}
{void serialize\_subtree(basic\_string$<$int32\_t$>$ \& into)}
{\texttt{into} - the string that contains the serialized trees of the knowledgebase}
{Converts the subtree into \stringtype and appended to \texttt{into}. This method is used during serialization} 
\end{detail}
%%%
\item \begin{detail}
{deserialize\_subtree**}
{bool deserialize\_subtree(basic\_string$<$int32\_t$>$::iterator \& it, \\ basic\_string$<$int32\_t$>$::iterator limit, int \& count)}
{
\texttt{it} - iterator to iterate over the string containing the word \\
\texttt{limit} - the last word that the subtree contains
\texttt{count} - \integer to count the subtrees
 }
{Returns \true after deserializing the subtrees. Returns \false if \texttt{it} and \texttt{limit} are equal.} 
\end{detail}
%%%
\item \begin{detail}
{get\_selfptr}
{node * get\_selfptr()}
{--}
{A self pointer that returns its own node.} 
\end{detail}
%%%
\item \begin{detail}
{max\_child\_count}
{int max\_child\_count()}
{--}
{Returns the maximum number of children existing in the knolwedgebase. If it returns ``n'', it implies that there may exist [0..n] suffixes.} 
\end{detail}
%%%
\item \begin{detail}
{has\_specific\_suffix}
{bool has\_specific\_suffix(answer specific\_answer)}
{\texttt{specific\_answer} - the answer that needs to be compared}
{Checks if a specific suffix/word has a specific answer. Returns \true if such a case exists, otherwise returns \false.} 
\end{detail}
%%%
\item \begin{detail}
{get\_label}
{int get\_label()}
{--}
{Returns the label of this node (which is the last symbol of the word that this node represents).} 
\end{detail}
%%%
\item \begin{detail}
{get\_word}
{list<int> get\_word()}
{--}
{Returns the word that this node represents.} 
\end{detail}
%%%
\item \begin{detail}
{mark\_required}
{bool mark\_required()}
{--}
{Returns \true if answer to this node is required. Returns \false if the answer is already known.} 
\end{detail}
%%%
\item \begin{detail}
{is\_required}
{bool is\_required()}
{--}
{Returns \true if this node is marked unknown and required, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{is\_answered}
{bool is\_answered()}
{--}
{Returns \true if this node is already answered, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{set\_answer}
{bool set\_answer(answer ans)}
{\texttt{ans} - answer that must be set.}
{Returns \true if the node is already answered and the answer is same as \texttt{ans}, otherwise \false. If the node is not answered already, then it returns \true after setting \texttt{ans} as the answer.} 
\end{detail}
%%%
\item \begin{detail}
{get\_answer}
{answer get\_answer()}
{--}
{Returns the answer of this node.} 
\end{detail}
%%%
\item \begin{detail}
{no\_subqueries}
{bool no\_subqueries(bool check\_self = true)}
{\texttt{check\_self} - Set to true. Used to check if the status of this node is marked required. }
{Returns \true if there are any queries with this node as the prefix, \false otherwise. Also returns \false if this node is not answered and marked required.} 
\end{detail}
%%%
\item \begin{detail}
{different}
{bool different(node * other)}
{\texttt{other} - a node whose answer needs to be compared to the current node. }
{Returns \true if this node and \texttt{other} node have the same answer, \false otherwise. } 
\end{detail}
%%%
\item \begin{detail}
{recursive\_different}
{bool recursive\_different(node * other, int depth)}
{\texttt{other} - a node whose answer needs to be compared to the current node.
 \texttt{depth} - the depth of the tree that indiciates the length of the word. }
{Compares the answers of the two nodes and their children upto a level specified by \texttt{depth}. Returns \true if there are no inconsistancies in the answers, \false otherwise. } 
\end{detail}
%%%
\item \begin{detail}
{is\_prefix\_of}
{bool is\_prefix\_of(node*other)}
{\texttt{other} - a node whose answer needs to be compared to the current node.}
{Retruns \true if this node is a suffix of the \texttt{other} node. } 
\end{detail}
%%%
\item \begin{detail}
{is\_suffix\_of}
{bool is\_suffix\_of(node*other)}
{\texttt{other} - a node whose answer needs to be compared to the current node.}
{Retruns \true if this node is a preffix of the \texttt{other} node. } 
\end{detail}
%%%
\item \begin{detail}
{get\_memory\_usage}
{unsigned long long int get\_memory\_usage()}
{--}
{Retruns the size of the memory used by this subtree. } 
\end{detail}
%%%
\item \begin{detail}
{ignore}
{void ignore()}
{--}
{Changes the status of this node to NODE\_IGNORE. } 
\end{detail}
%%%
\item \begin{detail}
{cleanup}
{bool cleanup()}
{--}
{Returns \true after deleting all the branches that has status as NODE\_IGNORE. } 
\end{detail}
%%%
\end{enumerate}

\subsection{Class - \texttt{iterator}}
\begin{enumerate}
\item \begin{detail}
{iterator}
{iterator()}
{--}
{Sets this node to NULL and initializes an iterator to the last node that is marked required. } 
\end{detail}
%%%
\item \begin{detail}
{iterator}
{iterator(const iterator \& other)}
{--}
{Sets the values of this node to those of the \texttt{other} node.} 
\end{detail}
%%%
\item \begin{detail}
{iterator**}
{iterator(bool queries\_only, typename list$<$node*$>$::iterator currentquery, node * current, knowledgebase * base)}
{\texttt{queries\_only} - a boolean variable that is \true if queries exist and \false if there are no queries in the knowledebase
 \texttt{currentquery} - iterator to iterate over queries
 \texttt{current} - the node under consideration
 \texttt{base} - the knowledgebase that is being processed.}
{Sets the values of this node to those specified in the arguement.} 
\end{detail}
%%%
\item \begin{detail}
{operator++}
{iterator \& operator++()}
{--}
{Operator overloading applied to ``++''. Creates an iterator that points to the next query and returns the node} 
\end{detail}
%%%
\item \begin{detail}
{operator++ **}
{iterator operator++(int foo)}
{--}
{--} 
\end{detail}
%%%
\item \begin{detail}
{is\_valid()}
{bool is\_valid()}
{--}
{Returns \true if the current iterator is not NULL, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{operator*}
{node \& operator*()}
{--}
{Returns the pointer to the current iterator.} 
\end{detail}
%%%
\item \begin{detail}
{operator-$>$}
{node * operator-$>$()}
{--}
{Returns the current iterator.} 
\end{detail}
%%%
\item \begin{detail}
{operator=}
{iterator \& operator=(const iterator \& it)}
{\texttt{it} - an iterator}
{Creates an iterator with the values of iterator \texttt{it} and returns this. } 
\end{detail}
%%%
\item \begin{detail}
{operator==}
{bool operator==(const iterator \& it)}
{\texttt{it} - an iterator}
{Returns \true if the current iterator is same as \texttt{it}, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{operator!=}
{bool operator!=(const iterator \& it)}
{\texttt{it} - an iterator}
{Returns \true if the current iterator is not equal to \texttt{it}, \false otherwise.} 
\end{detail}
\end{enumerate}



\subsection{Class - \knowledgebase}
\begin{enumerate}
%%%
\item \begin{detail}
{knowledgebase}
{knowledgebase()}
{--}
{Creates a knowledgebase with root as NULL.} 
\end{detail}
%%%
\item \begin{detail}
{knowledgebase}
{\~knowledgebase()}
{--}
{Deletes the knowledgebase by deleting the root.} 
\end{detail}
%%%
\item \begin{detail}
{clear}
{void clear()}
{--}
{Deletes the existing knowledgebase and creates a new knowledgebase containing only the root.} 
\end{detail}
%%%
\item \begin{detail}
{clear\_queries}
{void clear\_queries()}
{--}
{Deletes all the nodes that are marked as queries.} 
\end{detail}
%%%
\item \begin{detail}
{undo**}
{bool undo(unsigned int count)}
{\texttt{count} - }
{Used to undo the last operation.} 
\end{detail}
%%%
\item \begin{detail}
{get\_memory\_usage}
{unsigned long long int get\_memory\_usage()}
{--}
{Returns the memory used by the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{is\_answered}
{bool is\_answered()}
{--}
{Returns \true if there are no nodes marked required, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{is\_empty}
{bool is\_empty()}
{--}
{Returns \true if there are no nodes marked required and answered (the tree is empty), \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{count\_nodes}
{int count\_nodes()}
{--}
{Returns the number of nodes present in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{count\_answers}
{int count\_answers()}
{--}
{Returns the number of nodes that are already answered in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{count\_queries}
{int count\_queries()}
{--}
{Returns the number of nodes that are marked required in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{count\_resolved\_queries}
{int count\_resolved\_queries()}
{--}
{Returns the number of answered nodes that were once marked required.} 
\end{detail}
%%%
\item \begin{detail}
{reset\_resolved\_queries}
{void reset\_resolved\_queries()}
{--}
{Resets the number of resolved queries to zero.} 
\end{detail}
%%%
\item \begin{detail}
{get\_largest\_symbol}
{int get\_largest\_symbol()}
{--}
{Returns the largest symbol that is present in the knowledgebase. Essentially, this returns the number which is one less than the alphabet size.} 
\end{detail}
%%%
\item \begin{detail}
{check\_largest\_symbol}
{int check\_largest\_symbol()}
{--}
{Adjusts the largest symbol present in the knowledgebase and returns it.} 
\end{detail}
%%%
\item \begin{detail}
{print}
{void print(ostream \&os)}
{\texttt{os} - an output stream.}
{Prints the knowledgebase on the screen. Prints the word, status and the answer of all the words stored in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{tostring}
{string tostring()}
{--}
{Used to return a string stream for serialization.} 
\end{detail}
%%%
\item \begin{detail}
{generate\_dotfile}
{string generate\_dotfile()}
{--}
{Generates the ``.dot'' file of the knowledgebase for graphical representation.} 
\end{detail}
%%%
\item \begin{detail}
{serialize}
{basic\_string$<$int32\_t$>$ serialize()}
{--}
{Returns a string which represents the complete knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{deserialize**}
{bool deserialize(basic\_string$<$int32\_t$>$::iterator \&it, \\ basic\_string$<$int32\_t$>$::iterator limit)}
{\texttt{it} - iterator to iterate over the string containing the word.
 \texttt{limit} - iterator that points to the last word }
{Returns \true if the string was deserialized to knowledgebase successfully, \false if the deserialization failed.} 
\end{detail}
%%%
\item \begin{detail}
{deserialize\_query\_acceptances}
{bool deserialize\_query\_acceptances(basic\_string$<$int32\_t$>$::iterator \&it,\\ basic\_string$<$int32\_t$>$::iterator limit)}
{\texttt{it} - iterator to iterate over the string containing the word.
 \texttt{limit} - iterator that points to the last word }
{Returns \true after answering all the queries in the knowledgebase from a single serialized data. } 
\end{detail}
%%%
\item \begin{detail}
{create\_query\_tree}
{knowledgebase * create\_query\_tree()}
{--}
{Returns a tree created by adding to this tree, all the words marked as required in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{get\_queries}
{list$<$list$<$int$>$ $>$ get\_queries()}
{--}
{Returns a list of list of \integer that consists of all the queries existing in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{merge\_knowledgebase}
{bool merge\_knowledgebase(knowledgebase \& other\_tree)}
{\texttt{other\_tree} - the tree to be merged.}
{Returns \true if the current tree could be merged with the \texttt{other\_tree}, \false otherwise. Two trees can be merged only if they are consistant. This method merges only answered information, it does not merge the queries. } 
\end{detail}
%%%
\item \begin{detail}
{add\_knowledge}
{bool add\_knowledge(list$<$int$>$ \& word, answer acceptance)}
{\texttt{word} - the word to be added to the knowledgebase.
 \texttt{acceptance} - the classification of the word.}
{Returns \true if the knowledge for this word does not already exist and is successfully added to the knowledgebase, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{add\_query}
{int add\_query(list$<$int$>$ \& word, int prefix\_count = 0)}
{\texttt{word} - the word/query to be added to the knowledgebase.
 \texttt{prefix\_count} - initialized to zero. It is the count of all the prefixes that can be formed with the word.}
{Creates the query and the necessary prefixes (which will also be marked as a query) and returns the total number of queries formed.} 
\end{detail}
%%%
\item \begin{detail}
{resolve\_query}
{bool resolve\_query(list$<$int$>$ \& word, answer \& acceptance)}
{\texttt{word} - the word/query to be added to the knowledgebase.
 \texttt{acceptance} - the classification of the word.}
{If the word is already known and is answered, then the answer is assigned to \texttt{acceptance} and returns \true, otherwise returns \false.} 
\end{detail}
%%%
\item \begin{detail}
{resolve\_or\_add\_query}
{bool resolve\_or\_add\_query(list$<$int$>$ \& word, answer \& acceptance)}
{\texttt{word} - the word/query to be added to the knowledgebase.
 \texttt{acceptance} - the classification of the word.}
{Returns \true if the word is already known and answered, else marks the word as required and returns \false.} 
\end{detail}
%%%
\item \begin{detail}
{get\_nodeptr}
{node* get\_nodeptr(list$<$int$>$ \& word)}
{\texttt{word} - a word.}
{Returns the node that represents this word.} 
\end{detail}
%%%
\item \begin{detail}
{get\_rootptr}
{node* get\_rootptr()}
{--}
{Returns the root.} 
\end{detail}
%%%
\item \begin{detail}
{begin}
{iterator begin()}
{--}
{Returns an iterator that begins at the root node.} 
\end{detail}
%%%
\item \begin{detail}
{end}
{iterator end()}
{--}
{Returns an iterator which is used to point to the last node.} 
\end{detail}
%%%
\item \begin{detail}
{qbegin}
{iterator qbegin()}
{--}
{Returns an iterator that begins at the first node that is marked required.} 
\end{detail}
%%%
\item \begin{detail}
{qend}
{iterator qend()}
{--}
{Returns an iterator which is used to point to the last node that is marked required.} 
\end{detail}
\end{enumerate}

%%%%%%%%--------------------------------------------------------%%%%%%%%%%

%\textbf{methods not described} \vskip 1pt
%bool is\_lex\_smaller(node * other) \\
%bool is\_graded\_lex\_smaller(node * other) \\
%unsigned int get\_timestamp() \\
%string generate\_dotfile(equivalence\_relation \& eq) \\
%equivalence relation class\\
%class kIterator\_lex\_graded 

%%%%%%%%--------------------------------------------------------%%%%%%%%%%
