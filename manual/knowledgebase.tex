\chapter{The Knowledgebase}

The knowledgebase is the central repository of information. It is a database that stores words and their classification. Apart from this basic functionality, the knowledgebase also offers number of other features thereby increasing the support for extensibility.
These features are reflected in the implementation of the knowledgebase. The methods used in the knowledgebase can be divided into two categories - \textbf{\emph{Methods important for Using \libalf}} and \textbf{\emph{Methods important for expanding \libalf}}. 
\paragraph{}
The chapter discusses these methods from both a user's perspective and a developer's perspective. The material will include adequate account of its structure, operations and implementation.  The final section of this chapter will provide an appendix of all the methods used in programming the knowledgebase with a brief description corresponding to it.  
\vskip 1pt

\section{The knowledgebase - A User's Perspective}

\paragraph{} In this section, we describe the basic functionality of the knowledgebase and provide fundamental information that one would have to know to employ \libalf in an application. It will explicate functional practice of the database and some elementary details of methods to better understand how the operations are carried out. This section will not deal with elaboration of the internal structure or methods that can be used to extend the knowledgebase. To discover more about it, you may refer the section on Developer's Perspective and Methods in Detail.

\subsection*{Basic Concepts}
	
Definition of some key terms concerning the underlying concepts are listed below.

\paragraph{Alphabet} An alphabet is a finite set of symbols which is usually denoted by $\Sigma$. 
Symbols could be numbers (0,1,\ldots) or alphabets(a,b,\ldots) and so on. 
Alphabet size $\mid$ $\Sigma$ $\mid$ is the size of the set Alphabet. Since \libalf uses integers as symbols, the largest symbol in the alphabet is one less than the alphabet size.
Thus, when alphabet size of two is specified by the user, \libalf will use the following symbols. 
\[
\Sigma = \{0,1\}
\]
\[
\mid \Sigma \mid = 2
\]

This implies, that an alphabet size of two will result in the largest symbol being ``1''.

\paragraph{Word} A word ( $ w \in \Sigma \textsuperscript{*} $ ) is finite string formed by the concatenation of the symbols from $\Sigma$. Since the symbols used in \libalf are of type \integer, the words are operated as a \texttt{list} of \integer.  

\paragraph{Language} Language $ L = \Sigma \textsuperscript{*} $ is a set of words formed by symbols, given the alphabet.

Thus, in the context of the previous example, ``01101'' is a word from the given set of alphabet and the L = \{ 01101, 11011\} is a Language.

\subsection*{Words and Classifications} 
The knowledgebase of \libalf is an efficient storage of words and their classifications. Words are represented as \lists of \integer. Classification refers to a set of arbitrary values which that are mapped with the words. For instance, classification for a Finite Automata refers to \true or \false. Since the knowledgebase is a template class, arbitrary values can be used for storing the classification. 

\subsection*{Queries and Answers} 
The next important function of the knowledgebase is to store queries to help the learning algorithm build the conjecture. As mentioned in the Introduction, a query is a word whose classification is unknown and needs to be retrieved from the user or teacher. In other words, the query must be \emph{resolved} by the user. To resolve the query, user provides what is called an \emph{answer}. Thus, given a set of words and classifications, the knowledgebase stores them and when a learning algorithm processes these words to create the conjecture, queries that occur are also stored in the knowledgebase (which is later presented to the user for an answer).

\subsection*{Serialize and Deserialize} 
\libalf allows serialization and deserialization of the knowledgebase. The advantages of this feature is it offers portability. Serialization allows the user to save their current work done with \libalf as a linear representation. User can save the knowledgebase into the hard disk, share it over the internet, carry it and use it another machine and so on. Deserialization converts the linear form back to the tree structure for usage by the \libalf tool.

\subsection*{GraphViz Visualization} 
The knolwedgebase allows one to generate a GraphViz Visualization of the available information. User can produce a ``.dot'' file of the knowledgebase which can be executed by the GraphViz tool to create the pictorial representation.

\subsection*{Merging Knowledgebases} 
Apart from the essential functions, the knowledgebase can also be merged with another knowledgebase preserving the consistancy. These features are elaborated in forthcoming sections.

\subsection{Methods in Detail}
The section describes some of the methods to support understanding how the knowledgebase works and how it can be employed in an application. The knowledgebase is built on a class named \knowledgebase. The methods important for using \libalf are discussed below.
	
\subsection*{Creating the Knowledgebase}

\begin{itemize}
 \item \textbf{knowledgebase::knowledgebase()} \vskip 1pt
	The constructor of the \knowledgebase class creates the knowedgebase.
\end{itemize}
	
\subsection*{Adding Knowledge to the Knowledgebase} 
To add information into the knowledgebase, the following method is used.
\begin{itemize}
\item \textbf{knowledgebase::bool add\_knowledge(list$<$int$>$ \& word, answer acceptance)} \vskip 1pt
This is the key method that adds words and classifications to the knowledgebase. The parameter ``word'' represents the sample word and ``acceptance'' represents the classification of the word. 
\end{itemize}	

\subsection*{Handling Queries}
The next point of discussion is the part of knowledgebase that handles queries. When an online algorithm produces queries, they are stored in the knowledgebase and can be retrieved by the user for classification. To perform these operations, the user application uses the following methods.

\begin{enumerate}
\item \textbf{knowledgebase::knowledgebase * create\_query\_tree()} \vskip 1pt
The method creates a knowledgebase containing only the queries. Thus, the return type is set as \texttt{knowledgebase}.
	
\item \textbf{knowledgebase::list$<$list$<$int$>$$>$ get\_queries()} \vskip 1pt
This method returns the list of all the queries present in the knowledgebase.

\end{enumerate}

\subsection*{Alphabet in Knowledgebase}
At any point of time, one can retrieve the largest symbol being processed in the knowledgebase using the following method.

\begin{itemize}
\item \textbf{knowledgebase::int get\_largest\_symbol()} \vskip 1pt 
This method returns the largest symbol that exists in the knowledgebase. Since \libalf employs the usage of integers for storage of symbols, the result is not the size of the alphabet but one less than the alphabet size. The method is flexible only to increase in the alphabet size while working with the knowledgebase. If there was a decrease in the alphabet size, the method does reflect it. In such cases, the following method is more useful.

\item \textbf{knowledgebase::int check\_largest\_symbol()} \hfill \vskip 1pt
The method performs a check on the knowledgebase and realizes the largest symbol that is currently available. Hence, if there was a decrease in the size of the alphabet at some point of time, it is recorded when this method is called.
\end{itemize}	

\subsection*{Iterators}

The knowledgebase uses the \lists of \integer to represent the words. Subsequently, a \lists of \lists of \integer is used to represent many words in a sequence. This is particularly used when viewing the whole data or all the queries in the knowledgbase. To iterate over these lists and process the words, the following methods are used. 

\begin{enumerate}
\item \textbf{knowledgebase::iterator begin()} \vskip 1pt
	The method returns an iterator that begins at the root node.

\item \textbf{knowledgebase::iterator end()} \vskip 1pt
	The method returns the final or the end node for the iterator.
	 
\item \textbf{knowledgebase::iterator qbegin()} \vskip 1pt
	The method returns an iterator that begins at the first query present in the knowledgebase.
	
\item \textbf{knowledgebase::iterator qend()} \vskip 1pt
	It returns the end node for the iterator.
\end{enumerate}

The iteration over the words is performed by overloading the ``+'' operator. The following example explains the usage of this operator.
\begin{lstlisting}
iterator ki;
list<list<int> > ret;
for(ki = this->qbegin(); ki != this->qend(); ++ki)
	ret.push_back(ki->get_word());
\end{lstlisting}
Here, the iterator begins at the first query present in the knowledgebase and uses the ``get\_word()'' function to retrieve the query and adds it to ``ret''.

\subsection*{Displaying the knowledgebase}
The following two methods can be used to display the knowledgebase.

\begin{enumerate}

\item \textbf{knowledgebase::string tostring()} \vskip 1pt
It creates a \stringtype representation of the knowledebase.

\item \textbf{knowledgebase::string generate\_dotfile()} \vskip 1pt
The method creates a GraphViz Visualization of the entire knowledgebase. The \stringtype obtained can be saved as a ``.dot'' file which can be executed by the GraphViz tool to observe the graphical representation of the knowledgebase. 

\end {enumerate}

\subsection*{Serialize and Deserialize}
The ability to serialize and deserialize increases the portability of \libalf. The description of these two methods are given below.
	
\begin{enumerate}
\item \textbf{knowledgebase::basic\_string$<$int32\_t$>$ serialize()} \hfill \vskip 1pt
This method is used to convert the entire knowledgebase into a linear representation in the form of a \stringtype which is composed of integers.
\item \textbf{knowledgebase::bool deserialize(basic\_string$<$int32\_t$>$::iterator \&it, basic\_string$<$int32\_t$>$ ::iterator limit)} \hfill \vskip 1pt
This method is used to convert linear form that represents the knowledgebase into a tree-like structure.
\end{enumerate}	
	
\subsection*{Other Important Methods}
The following methods offer features which may prove useful in using as well as extending \libalf.
\begin{enumerate}
\item \textbf{unsigned long long int get\_memory\_usage()} \vskip 1pt
The method returns the memory used by the knowledgebase on the system. Using this method at some point could be a good way of deciding if cleanup() needs to be called or not. 
		
\item \textbf{bool merge\_knowledgebase(knowledgebase \& other\_tree)} \vskip 1pt
The method returns true after merging two consistant knowledgebases. Two knowledgebases are said to be consistant only if they contain similar words and answers. If inconsistant, the method returns \false. However, the method ignores the queries and merges only all the answered words from the two knolwedgebases.

\end{enumerate}



\section{Structure of the Knowledgbase - A Developer's Perspective}
The data structures used to design the structure of the knowledgebase offers more flexibility and expandability of \libalf. This can be explained as follows.

\subsection{Representation of a word in the Knowledgebase}
\paragraph{}
The knowledgebase can be described as a prefix tree with nodes representing words. Consider a word formed by N symbols/characters. In principal, the knowledebase does not \emph{store} the word at the node but stores the i\textsuperscript{th} symbol of the word (where \texttt{i}$>$0 and \texttt{i}$<$N). A pictorial representation of a tree-like structure of the knowedgebase is expressed below.

\begin{center}
\begin{tikzpicture}
[
   every node/.style={circle,inner sep=1pt,draw}
]
\node {root} [grow=right]
  child [red] {node {0}
    child [black] {node {0}}
    child [red] {node {1}
      child [black] {node {0}}
      child [red] {node {1}
	child [red] {node {0}
	  child [red] {node [circle,gray,draw] {1}}
	}
	child [black] {node {1}}
      }
    }
  }
  child {node {1}};
\end{tikzpicture}
\end{center}


\paragraph{}	
Consider the word \texttt{01101} as marked in the tree above. When this word is added to the knowledgebase, it is not stored as a single \stringtype at a node. Every symbol of the word is stored at a node and sequence of these symbols at depth six (starting from the root) constructs the word. Hence we say that the node circled gray \emph{represents} the word \texttt{01101}. Thus, the symbol \texttt{0} is a child of the root, the symbol \texttt{1} is the child of \texttt{0} and so on. One can reach the node representing the word by traversing from the root to the final child and accumulating the symbols that every node contains. Alternatively, one can also retrieve the word by ascending from a node to the root and reversing the word obtained. \libalf uses the latter technique. 
\vskip 1pt
	
\subsection{Description of the Structure}
	
The knowledgebase is designed as a template class enabling usage of arbitrary values for storing desired information.
The knowledgebase class contains the node class which describes the variables that are necessary for the node. This class also contains some of the internal methods which are important for both using and expanding \libalf.
The constructor of the class \node creates the root node with the following values to its attributes.
\begin{itemize}
\item \texttt{parent} \hfill \vskip 1pt A variable of type \node that points to the parent of the node.
\item \texttt{label} \hfill \vskip 1pt An \integer variable that contains the alphabet that the node represents. 
\item \texttt{status} \hfill \vskip 1pt The variable \textbf{status} indicates whether the classification of the word (the word is constructed by traversing through the tree) is required, answered or can be ignored. Since the knowledgebase is a prefix tree, it contains not only the supplied words but also stores the prefixes of the word. However, the status of these prefixes may not be of interest and can be \emph{ignored}. On the otherhand when the learning algorithm creates more words, it stores them into the knowledgebase for presenting it to the user. Classification to such words are \emph{required}. Thus, the variable differentiates these words. For this purpose, it is an \texttt{enum} type variable that can take one of three values ``NODE\_IGNORE'', ``NODE\_REQUIRED'' and ``NODE\_ANSWERED''. 
\item \texttt{ans} \hfill \vskip 1pt The variable stores the answer (or the acceptance criteria / classification) of the node. 
\end{itemize}
	
The child nodes that are created after this are referred by the \vectored type \node variable called \texttt{children}. 
The knowledgebase contains methods that act upon the node for the operations. 
These variables and methods form the building blocks of the knowledgebase. Some of the methods are described in the next section.

\subsection{Methods in Detail}
Having described the methods important for using \libalf in the previous section on user's perspective, this section provides description of few more methods that are useful for extending \libalf. The section will mostly contain the operations that can be performed over the node, methods on handling words, classifications and queries. Nevertheless, a complete list of methods and their explanation is given in the next section.

\subsection*{Creating the Root node}
When the knowledgebase is created, the root node is initialized. Its properties are definied by the constructor of the \node class.
\begin{itemize}
\item \textbf{node::node(knowledgebase * base)} \vskip 1pt
The method sets the following properties to the root node.
\begin{enumerate}
\item parent = NULL ; root node does not have a parent.
\item label = -1 ; which is equivalent to epsilon
\item status = STATUS\_IGNORE ; the acceptance rule or classification of the root node is initially not necessary.
\end{enumerate}	
\end{itemize}

	
\subsection*{Working with Nodes}
Methods operating on the nodes are mostly internal methods and cannot be accessed publicly.
\begin{enumerate}
\item \textbf{node::node* get\_next(node * current\_child)} \vskip 1pt
This function returns the next node or the next child of the current node (which is passed as an arguement). 
	
\item \textbf{node::node * get\_parent()} \vskip 1pt
The method returns the parent of the node under use.

\item \textbf{node::list$<$int$>$ get\_word()} \vskip 1pt
This function returns the word that the current node represents. The method traverses backwards in the tree (ascending from child to parent) and reverses the sequence obtained to build the correct word.
	
\item \textbf{node::int get\_label()} \hfill \vskip 1pt
This function returns the label that the node represents.
	
\item \textbf{node::node * find\_child(int label)} \hfill \vskip 1pt
The function is used to find the child node with the specified label.
	
\item \textbf{node::node * find\_descendant(list$<$int$>$ :: iterator infix\_start, list<int>::iterator infix\_limit)} \hfill \vskip 1pt
This function is used to find the child node specified by a word and returns the node. It traverses through the tree based on the iteration over the word to find the path that generates the required word.
	
\item \textbf{knowledgebase::node* get\_rootptr()} \hfill \vskip 1pt
The function returns the pointer to the root node of the knowledgebase.
	
\item \textbf{knowledgebase::node* get\_nodeptr(list$<$int$>$ \& word)} \hfill \vskip 1pt
This function returns the pointer to the current node specified by the word as the parameter.
	
\end{enumerate}

\subsection*{Words and Classification}

In principal, the primary focus of the knowledgebase is centered on storing words and classifications which constitutes the base for the learning algorithm to compute a conjecture. Methods related to this aspect are discussed below.
	
\begin{enumerate}
\item \textbf{node::node * find\_or\_create\_child(int label)} \vskip 1pt
	This function returns the child node given the label. However, if the node does not exist, it creates the child node with the specified label.
	
\item \textbf{node::node * find\_or\_create\_descendant(list$<$int$>$::iterator infix\_start, list$<$int$>$::iterator infix\_limit)} \hfill \vskip 1pt
	This function behaves almost similar to the previous one. However, the difference being, it does not operate with a single label but on a word (which is a list of \integer). 
\end{enumerate}	

 In fact, the method \texttt{add\_knowledge} simply calls the method \texttt{find\_or\_create\_descendant} so that the knowledge will be added only information about the word does not already exist in the knowledgebase.


\subsection*{Handling Queries}
Although some of the query handling methods have already been discussed, a few other important methods of interest are explained below. As mentioned previously, query handling depends more on the ``status'' of the word. This directly implies the \texttt{status} variable of the node. Operations made in regard to this is first described below.
\begin{enumerate}
\item \textbf{node::bool mark\_required()} \vskip 1pt
The method returns a boolean value \true if the acceptance or the classification of the node is requried (i.e, ``status'' is NODE\_REQUIRED) or \false if the classification is already known.
	
\item \textbf{node::bool is\_required()} \vskip 1pt
The method returns the ``status'' as \texttt{NODE\_REQUIRED}. It is used to set this status to a particular node under consideration.

\item \textbf{node::bool is\_answered()} \vskip 1pt
The method returns the ``status'' as \texttt{NODE\_ANSWERED}. It is used to set this status to a particular node under consideration.
	
\item \textbf{node::answer get\_answer()} \vskip 1pt
The method returns the answer (classification of the node) stored for the node. 
\end{enumerate}

\vskip 1pt
The following methods describe the operations associated with queries.

\begin{enumerate}

\item \textbf{knowledgebase::int add\_query(list$<$int$>$ \& word, int prefix\_count = 0)} \hfill \vskip 1pt
The method is primarily used to add a query to the knowledgebase. When the classification of a word has to be known, the method first checks if the word already exists with its classification in the knowledgebase (by using the \texttt{find\_or\_create\_child(int label)} method). Hence, if the classification of the word is unknown and does not already exist, the corresponding node will be created and eventually added in the query tree (since this method is used by \texttt{create\_query\_tree(\ldots)}.
  	
\item \textbf{knowledgebase::bool resolve\_query(list$<$int$>$ \& word, answer \& acceptance) and bool resolve\_or\_add\_query(list$<$int$>$ \& word, answer \& acceptance)} \hfill \vskip 1pt
These two methods can be described together as their functionality is almost similar and differ only in one aspect. Both methods return \true if the classification of the word is already known and \false if it is unknown. While ``resolve\_query()'' only returns \false, ``resolve\_or\_add\_query()'' marks the status of this word as required and then returns \false. Naturally, the former uses ``find\_descendant()'' and the latter makes use of ``find\_or\_create\_descendant()''.

\item \textbf{knowledgebase::void clear\_queries()} \hfill \vskip 1pt
This method is used to remove all the nodes that are identified or marked as a query.
\end{enumerate}
\vskip 1pt
\vskip 1pt

\subsection*{Alphabet in Knowledgebase}
This section gives an extended view of the concept of alphabet size in the knowledgebase. Although we have defined the basic concepts of alphabets in this chapter, the knowledgebase does not really store the alphabet size of the automaton specified by the user. The knowledgebase does not construt the tree based on the alphabet size specified by the user and is capable of constructing the tree precisely even if symbols outside the alphabet set are fed in the input (which includes the extra symbols). But, such improper input will lead to the learning algorithm computing a conjecture which might not be the expectation of the user.
However, the knowledgebase can at any point of time identify and operate on the alphabet size. This can be regarded as the largest symbol that is processed in the knowledgebase. Reiterating the fact mentioned already, that an alphabet size of 2 would contain ``1'' as the largest symbol, we discuss the following methods that work on the issue.
\begin{enumerate}
\item \textbf{knowledgebase::int get\_largest\_symbol()} \vskip 1pt
This is already described in the section on user's perspective. But some secondary information about this would be the fact that the method directly returns what is available in the variable ``largest\_symbol''. It does not check whether the alphabet size has been modified. A good way to do that would be to use the methods listed below.
	
\item \textbf{knowledgebase::int check\_largest\_symbol()} \hfill \vskip 1pt
The method performs a check on the knowledgebase and realizes the largest symbol that is currently available. Hence, if there was a change in the size of the alphabet at some point of time, it is automatacially adjusted when this method is called.
	
\item \textbf{bool cleanup()} \hfill \vskip 1pt
This method is used to clean the knowledgebase by removing all the unnecessary branches i.e, branches that consists only of IGNORE as the status. This is an example for a method that can cause a change in the largest symbol. If only the branches contain a particular symbol and they are removed in the clean up, it subsequentely causes a change in the largest symbol. 
\end{enumerate}

\subsection*{Displaying the knowledgebase}
Having described two methods in the previous section on the same topic, what is listed below is one other method which could be useful from the eye of a developer. \vskip 2pt
\textbf{void print(ostream \&os)} \vskip 1pt
This method prints the knowledgbase to any kind of an output stream. It prints the word, its status and the answer of all the words available in the knowledgebase.
\vskip 1pt
These methods described would summerize the most important methods from the view of a developer.
	
\section{Methods Specifications}
The section supplies a comprehensive list of all the methods used in the knowledgebase along account of their particulars. The section is divided based on on the class that the methods belong to.
\subsection{Class - \node}
\begin{enumerate}
%%%
\item \begin{detail}
{get\_next}
{node* get\_next(node * current\_child)}
{current\_child - The current child}
{Returns the next node} 
\end{detail}
%%%
\item \begin{detail}
{Constructor}
{node(knowledgebase * base)}
{base - the name of the knowledgebase}
{Creates the root node of the knowledgebase and sets its \texttt{parent} to NULL} 
\end{detail}
%%%
\item \begin{detail}
{get\_parent}
{node * get\_parent()}
{--}
{Returns the parent of the node that calls this function} 
\end{detail}
%%%
\item \begin{detail}
{find\_child}
{node * find\_child(int label)}
{label - the label that the child node must contain}
{Returns the node that contains the label specified as the parameter} 
\end{detail}
%%%
\item \begin{detail}
{find\_descendant}
{node * find\_descendant(list$<$int$>$::iterator infix\_start,\\ list$<$int$>$::iterator infix\_limit)}
{infix\_start - the word or symbol that is the starting point \\ infix\_limit - the word which is to be found}
{Returns the node that represents the word infix\_limit} 
\end{detail}
%%%
\item \begin{detail}
{find\_or\_create\_child}
{node * find\_or\_create\_child(int label)}
{label - the label that the child node must contain}
{Returns the node that contains the label specified as parameter. If not found, it creates such a node and returns it.} 
\end{detail}
%%%
\item \begin{detail}
{serialize\_subtree}
{void serialize\_subtree(basic\_string$<$int32\_t$>$ \& into)}
{\texttt{into} - the string that contains the serialized trees of the knowledgebase}
{Converts the subtree into \stringtype and appended to \texttt{into}. This method is used during serialization} 
\end{detail}
%%%
\item \begin{detail}
{deserialize\_subtree**}
{bool deserialize\_subtree(basic\_string$<$int32\_t$>$::iterator \& it, \\ basic\_string$<$int32\_t$>$::iterator limit, int \& count)}
{
\texttt{it} - iterator to iterate over the string containing the word \\
\texttt{limit} - the last word that the subtree contains
\texttt{count} - \integer to count the subtrees
 }
{Returns \true after deserializing the subtrees. Returns \false if \texttt{it} and \texttt{limit} are equal.} 
\end{detail}
%%%
\item \begin{detail}
{get\_selfptr}
{node * get\_selfptr()}
{--}
{A self pointer that returns its own node.} 
\end{detail}
%%%
\item \begin{detail}
{max\_child\_count}
{int max\_child\_count()}
{--}
{Returns the maximum number of children existing in the knolwedgebase. If it returns ``n'', it implies that there may exist [0..n] suffixes.} 
\end{detail}
%%%
\item \begin{detail}
{has\_specific\_suffix}
{bool has\_specific\_suffix(answer specific\_answer)}
{\texttt{specific\_answer} - the answer that needs to be compared}
{Checks if a specific suffix/word has a specific answer. Returns \true if such a case exists, otherwise returns \false.} 
\end{detail}
%%%
\item \begin{detail}
{get\_label}
{int get\_label()}
{--}
{Returns the label of this node (which is the last symbol of the word that this node represents).} 
\end{detail}
%%%
\item \begin{detail}
{get\_word}
{list<int> get\_word()}
{--}
{Returns the word that this node represents.} 
\end{detail}
%%%
\item \begin{detail}
{mark\_required}
{bool mark\_required()}
{--}
{Returns \true if answer to this node is required. Returns \false if the answer is already known.} 
\end{detail}
%%%
\item \begin{detail}
{is\_required}
{bool is\_required()}
{--}
{Returns \true if this node is marked unknown and required, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{is\_answered}
{bool is\_answered()}
{--}
{Returns \true if this node is already answered, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{set\_answer}
{bool set\_answer(answer ans)}
{\texttt{ans} - answer that must be set.}
{Returns \true if the node is already answered and the answer is same as \texttt{ans}, otherwise \false. If the node is not answered already, then it returns \true after setting \texttt{ans} as the answer.} 
\end{detail}
%%%
\item \begin{detail}
{get\_answer}
{answer get\_answer()}
{--}
{Returns the answer of this node.} 
\end{detail}
%%%
\item \begin{detail}
{no\_subqueries}
{bool no\_subqueries(bool check\_self = true)}
{\texttt{check\_self} - Set to true. Used to check if the status of this node is marked required. }
{Returns \true if there are any queries with this node as the prefix, \false otherwise. Also returns \false if this node is not answered and marked required.} 
\end{detail}
%%%
\item \begin{detail}
{different}
{bool different(node * other)}
{\texttt{other} - a node whose answer needs to be compared to the current node. }
{Returns \true if this node and \texttt{other} node have the same answer, \false otherwise. } 
\end{detail}
%%%
\item \begin{detail}
{recursive\_different}
{bool recursive\_different(node * other, int depth)}
{\texttt{other} - a node whose answer needs to be compared to the current node.
 \texttt{depth} - the depth of the tree that indiciates the length of the word. }
{Compares the answers of the two nodes and their children upto a level specified by \texttt{depth}. Returns \true if there are no inconsistancies in the answers, \false otherwise. } 
\end{detail}
%%%
\item \begin{detail}
{is\_prefix\_of}
{bool is\_prefix\_of(node*other)}
{\texttt{other} - a node whose answer needs to be compared to the current node.}
{Retruns \true if this node is a suffix of the \texttt{other} node. } 
\end{detail}
%%%
\item \begin{detail}
{is\_suffix\_of}
{bool is\_suffix\_of(node*other)}
{\texttt{other} - a node whose answer needs to be compared to the current node.}
{Retruns \true if this node is a preffix of the \texttt{other} node. } 
\end{detail}
%%%
\item \begin{detail}
{get\_memory\_usage}
{unsigned long long int get\_memory\_usage()}
{--}
{Retruns the size of the memory used by this subtree. } 
\end{detail}
%%%
\item \begin{detail}
{ignore}
{void ignore()}
{--}
{Changes the status of this node to NODE\_IGNORE. } 
\end{detail}
%%%
\item \begin{detail}
{cleanup}
{bool cleanup()}
{--}
{Returns \true after deleting all the branches that has status as NODE\_IGNORE. } 
\end{detail}
%%%
\end{enumerate}

\subsection{Class - \texttt{iterator}}
\begin{enumerate}
\item \begin{detail}
{iterator}
{iterator()}
{--}
{Sets this node to NULL and initializes an iterator to the last node that is marked required. } 
\end{detail}
%%%
\item \begin{detail}
{iterator}
{iterator(const iterator \& other)}
{--}
{Sets the values of this node to those of the \texttt{other} node.} 
\end{detail}
%%%
\item \begin{detail}
{iterator**}
{iterator(bool queries\_only, typename list$<$node*$>$::iterator currentquery, node * current, knowledgebase * base)}
{\texttt{queries\_only} - a boolean variable that is \true if queries exist and \false if there are no queries in the knowledebase
 \texttt{currentquery} - iterator to iterate over queries
 \texttt{current} - the node under consideration
 \texttt{base} - the knowledgebase that is being processed.}
{Sets the values of this node to those specified in the arguement.} 
\end{detail}
%%%
\item \begin{detail}
{operator++}
{iterator \& operator++()}
{--}
{Operator overloading applied to ``++''. Creates an iterator that points to the next query and returns the node} 
\end{detail}
%%%
\item \begin{detail}
{operator++ **}
{iterator operator++(int foo)}
{--}
{--} 
\end{detail}
%%%
\item \begin{detail}
{is\_valid()}
{bool is\_valid()}
{--}
{Returns \true if the current iterator is not NULL, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{operator*}
{node \& operator*()}
{--}
{Returns the pointer to the current iterator.} 
\end{detail}
%%%
\item \begin{detail}
{operator-$>$}
{node * operator-$>$()}
{--}
{Returns the current iterator.} 
\end{detail}
%%%
\item \begin{detail}
{operator=}
{iterator \& operator=(const iterator \& it)}
{\texttt{it} - an iterator}
{Creates an iterator with the values of iterator \texttt{it} and returns this. } 
\end{detail}
%%%
\item \begin{detail}
{operator==}
{bool operator==(const iterator \& it)}
{\texttt{it} - an iterator}
{Returns \true if the current iterator is same as \texttt{it}, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{operator!=}
{bool operator!=(const iterator \& it)}
{\texttt{it} - an iterator}
{Returns \true if the current iterator is not equal to \texttt{it}, \false otherwise.} 
\end{detail}
\end{enumerate}



\subsection{Class - \knowledgebase}
\begin{enumerate}
%%%
\item \begin{detail}
{knowledgebase}
{knowledgebase()}
{--}
{Creates a knowledgebase with root as NULL.} 
\end{detail}
%%%
\item \begin{detail}
{knowledgebase}
{\~knowledgebase()}
{--}
{Deletes the knowledgebase by deleting the root.} 
\end{detail}
%%%
\item \begin{detail}
{clear}
{void clear()}
{--}
{Deletes the existing knowledgebase and creates a new knowledgebase containing only the root.} 
\end{detail}
%%%
\item \begin{detail}
{clear\_queries}
{void clear\_queries()}
{--}
{Deletes all the nodes that are marked as queries.} 
\end{detail}
%%%
\item \begin{detail}
{undo**}
{bool undo(unsigned int count)}
{\texttt{count} - }
{Used to undo the last operation.} 
\end{detail}
%%%
\item \begin{detail}
{get\_memory\_usage}
{unsigned long long int get\_memory\_usage()}
{--}
{Returns the memory used by the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{is\_answered}
{bool is\_answered()}
{--}
{Returns \true if there are no nodes marked required, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{is\_empty}
{bool is\_empty()}
{--}
{Returns \true if there are no nodes marked required and answered (the tree is empty), \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{count\_nodes}
{int count\_nodes()}
{--}
{Returns the number of nodes present in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{count\_answers}
{int count\_answers()}
{--}
{Returns the number of nodes that are already answered in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{count\_queries}
{int count\_queries()}
{--}
{Returns the number of nodes that are marked required in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{count\_resolved\_queries}
{int count\_resolved\_queries()}
{--}
{Returns the number of answered nodes that were once marked required.} 
\end{detail}
%%%
\item \begin{detail}
{reset\_resolved\_queries}
{void reset\_resolved\_queries()}
{--}
{Resets the number of resolved queries to zero.} 
\end{detail}
%%%
\item \begin{detail}
{get\_largest\_symbol}
{int get\_largest\_symbol()}
{--}
{Returns the largest symbol that is present in the knowledgebase. Essentially, this returns the number which is one less than the alphabet size.} 
\end{detail}
%%%
\item \begin{detail}
{check\_largest\_symbol}
{int check\_largest\_symbol()}
{--}
{Adjusts the largest symbol present in the knowledgebase and returns it.} 
\end{detail}
%%%
\item \begin{detail}
{print}
{void print(ostream \&os)}
{\texttt{os} - an output stream.}
{Prints the knowledgebase on the screen. Prints the word, status and the answer of all the words stored in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{tostring}
{string tostring()}
{--}
{Used to return a string stream for serialization.} 
\end{detail}
%%%
\item \begin{detail}
{generate\_dotfile}
{string generate\_dotfile()}
{--}
{Generates the ``.dot'' file of the knowledgebase for graphical representation.} 
\end{detail}
%%%
\item \begin{detail}
{serialize}
{basic\_string$<$int32\_t$>$ serialize()}
{--}
{Returns a string which represents the complete knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{deserialize**}
{bool deserialize(basic\_string$<$int32\_t$>$::iterator \&it, \\ basic\_string$<$int32\_t$>$::iterator limit)}
{\texttt{it} - iterator to iterate over the string containing the word.
 \texttt{limit} - iterator that points to the last word }
{Returns \true if the string was deserialized to knowledgebase successfully, \false if the deserialization failed.} 
\end{detail}
%%%
\item \begin{detail}
{deserialize\_query\_acceptances}
{bool deserialize\_query\_acceptances(basic\_string$<$int32\_t$>$::iterator \&it,\\ basic\_string$<$int32\_t$>$::iterator limit)}
{\texttt{it} - iterator to iterate over the string containing the word.
 \texttt{limit} - iterator that points to the last word }
{Returns \true after answering all the queries in the knowledgebase from a single serialized data. } 
\end{detail}
%%%
\item \begin{detail}
{create\_query\_tree}
{knowledgebase * create\_query\_tree()}
{--}
{Returns a tree created by adding to this tree, all the words marked as required in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{get\_queries}
{list$<$list$<$int$>$ $>$ get\_queries()}
{--}
{Returns a list of list of \integer that consists of all the queries existing in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{merge\_knowledgebase}
{bool merge\_knowledgebase(knowledgebase \& other\_tree)}
{\texttt{other\_tree} - the tree to be merged.}
{Returns \true if the current tree could be merged with the \texttt{other\_tree}, \false otherwise. Two trees can be merged only if they are consistant. This method merges only answered information, it does not merge the queries. } 
\end{detail}
%%%
\item \begin{detail}
{add\_knowledge}
{bool add\_knowledge(list$<$int$>$ \& word, answer acceptance)}
{\texttt{word} - the word to be added to the knowledgebase.
 \texttt{acceptance} - the classification of the word.}
{Returns \true if the knowledge for this word does not already exist and is successfully added to the knowledgebase, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{add\_query}
{int add\_query(list$<$int$>$ \& word, int prefix\_count = 0)}
{\texttt{word} - the word/query to be added to the knowledgebase.
 \texttt{prefix\_count} - initialized to zero. It is the count of all the prefixes that can be formed with the word.}
{Creates the query and the necessary prefixes (which will also be marked as a query) and returns the total number of queries formed.} 
\end{detail}
%%%
\item \begin{detail}
{resolve\_query}
{bool resolve\_query(list$<$int$>$ \& word, answer \& acceptance)}
{\texttt{word} - the word/query to be added to the knowledgebase.
 \texttt{acceptance} - the classification of the word.}
{If the word is already known and is answered, then the answer is assigned to \texttt{acceptance} and returns \true, otherwise returns \false.} 
\end{detail}
%%%
\item \begin{detail}
{resolve\_or\_add\_query}
{bool resolve\_or\_add\_query(list$<$int$>$ \& word, answer \& acceptance)}
{\texttt{word} - the word/query to be added to the knowledgebase.
 \texttt{acceptance} - the classification of the word.}
{Returns \true if the word is already known and answered, else marks the word as required and returns \false.} 
\end{detail}
%%%
\item \begin{detail}
{get\_nodeptr}
{node* get\_nodeptr(list$<$int$>$ \& word)}
{\texttt{word} - a word.}
{Returns the node that represents this word.} 
\end{detail}
%%%
\item \begin{detail}
{get\_rootptr}
{node* get\_rootptr()}
{--}
{Returns the root.} 
\end{detail}
%%%
\item \begin{detail}
{begin}
{iterator begin()}
{--}
{Returns an iterator that begins at the root node.} 
\end{detail}
%%%
\item \begin{detail}
{end}
{iterator end()}
{--}
{Returns an iterator which is used to point to the last node.} 
\end{detail}
%%%
\item \begin{detail}
{qbegin}
{iterator qbegin()}
{--}
{Returns an iterator that begins at the first node that is marked required.} 
\end{detail}
%%%
\item \begin{detail}
{qend}
{iterator qend()}
{--}
{Returns an iterator which is used to point to the last node that is marked required.} 
\end{detail}
\end{enumerate}

%%%%%%%%--------------------------------------------------------%%%%%%%%%%

%\textbf{methods not described} \vskip 1pt
%bool is\_lex\_smaller(node * other) \\
%bool is\_graded\_lex\_smaller(node * other) \\
%unsigned int get\_timestamp() \\
%string generate\_dotfile(equivalence\_relation \& eq) \\
%equivalence relation class\\
%class kIterator\_lex\_graded 

%%%%%%%%--------------------------------------------------------%%%%%%%%%%
