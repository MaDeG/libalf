\chapter{The Knowledgebase}

The knowledgebase is the central repository of information. It is a database that stores words and their classification. Apart from this basic functionality, the knowledgebase also offers number of other features thereby increasing extensibility support. 
But we have not designed our knowledgebase to do just that but also to provide extensibility. In this regard, the methods used implementation of knowledgebase can be divided into two categories - \textbf{\emph{Methods important for Using \libalf}} and \textbf{\emph{Methods important for expanding \libalf}}. 
\paragraph{}
In this chapter, we shall discuss the knowledgebase from a user's perspective and a developer's perspective. The material will include adequate account of its structure, operations and implementation.  The final section of this chapter will provide an appendix of all the methods used in programming the knowledgebase with a brief description corresponding to it.  
\vskip 1pt
(A PICTURE OF KNOWLEDGEBASE FROM DEMO HERE)

\section{The knowledgebase - A User's Perspective}

\paragraph{} In this section, we describe the basic functionality of the knowledgebase. The following material provides fundamental information that one would have to know to employ \libalf in an application. This section will not deal with explanation of the internal structure or methods used for operations of the knowledgebase. However, it will provide some elementary details of methods that could be required to better understand an operation.  To discover more on those areas, you may refer the section on Developer's Perspective and Methods in Detail.

\subsection*{Basic Concepts}
	
	To understand the functions of the knowledgebase, it is important to know the basic underlying concepts. We shall define some key terms for a start.
	
\paragraph{Symbol} It is an arbitrary data which has some meaning to or effect on the machine. It is elementary data on which an automaton is built. 

\paragraph{Alphabet} It is a finite set of symbols. An alphabet set is usually denoted by $\Sigma$.
\vskip 1pt
\[
\sum = \{0,1,\ldots\}
\]

For example, in \libalf, when alphabet size of two is specified by the user, then by default the alphabets involved in the automaton would be 
\[
\sum = \{0,1\}
\]

This leads us to define the following.

\paragraph{Word} A finite string formed by the concatenation of a number of symbols.

\paragraph{Language} Language is a set of words, formed by symbols in a given alphabet.

Thus, adding to our previous example, ``01101'' would be a word from the given set of alphabet and the set \{ 01101, 11011\} would be a Language.

\subsection*{Storing Words} 
The knowledgebase of \libalf is an efficient storage of words and their classifications. Classifications are nothing but the acceptance rules of the word i.e., whether the word has to be accepted or rejected by the automaton. The knowledgebase maintains information about this with the variable \texttt{status}. Since the knowledgebase can use arbitrary values, one may choose to store this information in any form. 

\subsection*{Queries and Answers} 
The next major function of the knowledgebase would be to store queries to help the learning algorithm build the automaton. As mentioned in the previous chapter, a query is nothing but a word whose classification is unknown and needs to be retrieved from the user or teacher. This is called the answer. Hence, given a set of words and classifications, the knowledgebase can store them and when a learning algorithm processes these words, queries created that are also stored in the knowledgebase (which are later presented to the user).

\subsection*{Other features} 
Apart from the essential functions, the knowledgebase also provides certain features that can be made us of when employing it in an application. The knowledge available in the knowledgebase can be also be serialized into the user's hard disk. Also, the knolwedgebase allows one to generate a dot file of the knowledge available to have a graphical representation of the same. All the more, the knowledgebase can also be merged with another knowledgebase without introducing any errors. These features are elaborated in forthcoming sections.

\section{Structure of the Knowledgbase - A Developer Perspective}

\subsection{Representation of a word in the Knowledgebase}
\paragraph{}
	Ideally, the first step towards understanding the organization of the knowledgebase would be to realize how a word is represented in it.
\paragraph{}
	Generally, the knowledgebase can be described as a tree structure with nodes representing the words. More precisely, it is a prefix tree. Given this description and the demo programs from the website (which even presents a graphical representation of the tree), one would imagine a word \texttt{01101} in the knowledgebase as a tree with a node that holding a \stringtype or \texttt{list of integers} with value ``01101''. However, this is \textbf{NOT} how knowledgebase is implemented in \libalf.
\paragraph{}
	The node by itself does \emph{not} contain the complete word, but only contains the i\textsuperscript{th} symbol of the word. An example can make things clear. 
\paragraph{}	
	Consider a word \texttt{01101}. When this word is added to the knowledgebase, it is not stored as a single \stringtype at a node of the tree, instead the sequence of the symbols that comprise the word construct the branch of the tree with every node representing exactly one symbol. This implies, to represent this word in the knowledgebase, the root (which is always an empty string represented by Epsilon) creates a child node that represtents ``0''. The next symbole of the word ``1'' is now represented in a node which is the child of the node representing its previous symbol ( or the parent node), ``0''. Thus, one can reach the node representing the word \texttt{01101} by following the 0\textsuperscript{th} child of the root node, then further accessing the first child of this node and so on.
\paragraph{}
	Hence, to retrive a word from the tree, one has to traverse down from the root node to the final child node by accumulating the symbols that every node represents. Alternatively, one can also recover the word by ascending from a node to the root and reversing the word obtained. \libalf uses the latter technique. 
	\vskip 1pt

	(A PICTURE OF THE ABOVE EXPLAINED TREE HERE)	
	
\subsection{Description of the Structure}
	
	The knowledgebase is designed as a template class enabling usage of arbitrary values for storing desired information.
	The knowledgebase class contains the node class which describes the variables that are necessary for the node. This class also contains some of the internal methods which are important for both using and expanding \libalf.
	The constructor of the node class creates the tree, more precisely (a root node) with the following variables that define the node.
	\begin{itemize}
	\item \texttt{parent} \hfill \vskip 1pt A variable of type \node that points to the parent of the node.
	\item \texttt{label} \hfill \vskip 1pt An \integer variable that contains the alphabet that the node represents. 
	\item \texttt{status} \hfill \vskip 1pt This indicates whether the classification of the word (the word is constructed by traversing through the tree) is required, answered or can be ignored. It is an \texttt{enum} type variable with the respective three values ``NODE\_IGNORE'', ``NODE\_REQUIRED'' and ``NODE\_ANSWERED''. 
	\item \texttt{ans} \hfill \vskip 1pt The variable stores the answer (or the acceptance criteria / classification) of the node. 
	\end{itemize}
	
	After constructing the root node, the child nodes are created with the \vectored type \node variable called \texttt{children}. 
	The knowledgebase contains methods that act upon the node for the operations. 
	These variables and methods form the building blocks of knowledgebase. The methods employed in the knowledgebase is described in the next section.

\section{Working of the Knowledgebase and its Methods}

	In this section we will discuss most of the methods used in the knowledgebase. The description given below pertains more to a developer as it is inclined to describe the methods in correspondance to the workflow of the knowledgebase. 

\subsection{Creating the Knowledgebase}

	The knowledgebase is created by the constructor of the class \texttt{node}. It is initialized with the following properties. \vskip 1pt
\textbf{node(knowledgebase * base)} \hfill \vskip 1pt
	The constructor of the node creates the root node of the knowledgebase by setting values for the variables as follows.
	\begin{enumerate}
	\item parent - NULL ; root node does not have a parent.
	\item label - -1 ; which is equivalent to epsilon
	\item status - STATUS\_IGNORE ; the acceptance rule or classification of the root node is initially not necessary.
	\end{enumerate}

\subsection{Nodes}
	Having described how the knowledgebase is created, we describe some of the functions that concerns the node. These are internal methods and they perform some basic operations as discussed below.
\begin{enumerate}
\item \textbf{node* get\_next(node * current\_child)} \hfill \vskip 1pt
	This function returns the next node or the next child of the current node (which is passed as an arguement). 
	
\item \textbf{node * get\_parent()} \hfill \vskip 1pt
	The method returns the parent of the node under use.

\item \textbf{list$<$int$>$ get\_word()} \hfill \vskip 1pt
	This function returns the word that the current node represents. The method traverses backwards in the tree (ascending from child to parent) and reverses the sequence obtained to build the correct word.
	
\item \textbf{int get\_label()} \hfill \vskip 1pt
	This function returns the label that the node represents.
	
\item \textbf{node * find\_child(int label)} \hfill \vskip 1pt
	The function is used to find the child node with the specified label.
	
\item \textbf{node * find\_descendant(list$<$int$>$ :: iterator infix\_start, list<int>::iterator infix\_limit)} \hfill \vskip 1pt
	This function is used to find the child node specified by a word. It traverses through the tree based on the iteration over the word to find the path that generates the required word.
	
\item \textbf{node* get\_rootptr()} \hfill \vskip 1pt
	The function returns the pointer to the root node.
	
\item \textbf{node* get\_nodeptr(list$<$int$>$ \& word)} \hfill \vskip 1pt
	This function returns the pointer to the current node specified by the word as the parameter.
	
\end{enumerate}

\subsection{Words and Classification}

	In principal, the primary purpose of the knowledgebase is to store the words and classifications that constitutes the base for the learning algorithm to compute an automaton. We discuss the following two functions of the node and a method relating to this important aspect.
\begin{enumerate}
\item \textbf{node * find\_or\_create\_child(int label)} \hfill \vskip 1pt
	This function returns the child node given the label. However, if the node does not exist, it creates the child node with the specified label.
	
\item \textbf{node * find\_or\_create\_descendant(list$<$int$>$::iterator infix\_start, list$<$int$>$::iterator infix\_limit)} \hfill \vskip 1pt
	This function behaves almost similar to the previous one. However, the difference being, it does not operate with a single label but on a word (which is a list of \integer). 
	
\item \textbf{bool add\_knowledge(list$<$int$>$ \& word, answer acceptance)} \hfill \vskip 1pt
	This is the key function that adds information to the knowledgebase. The parameter ``word'' represents the sample word and ``acceptance'' represents the classification of the word. 
	This method simply calls the ``find\_or\_create\_descendant(list$<$int$>$::iterator infix\_start, list$<$int$>$::iterator infix\_limit)'' so that the knowledge will be added only information about the word does not already exist in the knowledgebase.
\end{enumerate}	

\subsection{Queries}

	The next point of discussion would be the part of knowledgebase that handles queries. For instance, an online algorithm produces queries at every ``advance'' of the algorithm. These queries are stored in the knowledgebase and are later presented to the user for classification.
\paragraph{}
	To understand the implementation of query handling in \libalf's knowledgebase, one must first know the functionality of three methods that are crucial for query handling.

\begin{enumerate}
\item \textbf{bool mark\_required()} \hfill \vskip 1pt
	The method returns a boolean value \true if the acceptance or the classification of the node is requried (i.e, ``status'' is NODE\_REQUIRED) or \false if the classification is already known.
	
\item \textbf{bool is\_required()} \hfill \vskip 1pt
	The method returns the ``status'' as \texttt{NODE\_REQUIRED}. It is used to set this status to a particular node under consideration.

\item \textbf{bool is\_answered()} \hfill \vskip 1pt
	The method returns the ``status'' as \texttt{NODE\_ANSWERED}. It is used to set this status to a particular node under consideration.
	
\item \textbf{answer get\_answer()} \hfill \vskip 1pt
	The method returns the answer (classification of the node) stored for the node. 
	
\end{enumerate}

\vskip 1pt
  The following methods describe the operations associated with queries.

\begin{enumerate}
\item \textbf{knowledgebase * create\_query\_tree()} \hfill vskip 1pt
	The method creates a tree containing the queries to be answered. Therefore, its return type is \texttt{knowledgebase}.
It uses the \texttt{get\_word()} method to retrive the word and uses the \texttt{add\_query()} method add it in the tree.

\item \textbf{int add\_query(list$<$int$>$ \& word, int prefix\_count = 0)} \hfill \vskip 1pt
	The method is primarily used to add the word into the query tree. When the classification of a word has to be known, the method firsst checks if the word already exists with its classification in the knowledgebase (by using the \texttt{find\_or\_create\_child(int label)} method). Hence, if the classification of the word is unknown and does not already exist, the corresponding node will be created and eventually added in the query tree (since this method is used by \texttt{create\_query\_tree(\ldots)}.
  
\item \textbf{list$<$list$<$int$>$$>$ get\_queries()} \hfill \vskip 1pt
	This method returns the list of all the queries present in the knowledgebase (i.e, all words yet to classified). Naturally, the method uses the \texttt{get\_word()} function to build the word.
	
\item \textbf{bool resolve\_query(list$<$int$>$ \& word, answer \& acceptance) and bool resolve\_or\_add\_query(list$<$int$>$ \& word, answer \& acceptance)} \hfill \vskip 1pt
	These two methods can be described together as their functionality is almost similar and differ only in one aspect. Both methods return \true if the classification of the word is already known and \false if it is unknown. While ``resolve\_query()'' only returns \false, ``resolve\_or\_add\_query()'' marks the status of this word as required and then returns \false. Naturally, the former uses ``find\_descendant()'' and the latter makes use of ``find\_or\_create\_descendant()''.

\item \textbf{void clear\_queries()} \hfill \vskip 1pt
	This method is used to remove all the nodes that are identified or marked as a query.
\end{enumerate}
\vskip 1pt
\vskip 1pt

\subsection{Alphabets in Knowledgebase}
	Although we have defined the basic concepts that includes alphabets in this chapter, the knowledgebase does not really store the alphabet size of the automaton specified by the user. The knowledgebase does not construt the tree based on the alphabet size specified by the user and is capable of constructing the tree precisely even if symbols outside the alphabet set are fed in the input (which includes the extra symbols). But, such improper input will lead to the learning algorithm computing a conjecture which might not be the expectation of the user.
	However, the knowledgebase can at any point of time identify and operate on the alphabet size. This can be regarded as the largest symbol that is processed in the knowledgebase. From Section --, we know that for an alphabet size of 2, the largest symbol would be ``1''.
One can use the following two methods available.
\begin{enumerate}
\item \textbf{int get\_largest\_symbol()} \hfill \vskip 1pt
	This method returns the largest symbol that exists in the knowledgebase. This is stored in a variable called ``largestsymbol''. This method only returns the variable but does not check the knowledgebase for the largest symbol.
\item \textbf{int check\_largest\_symbol()} \hfill \vskip 1pt
	The method performs a check on the knowledgebase and realizes the largest symbol that is currently available. Hence, if there was a change in the size of the alphabet at some point of time, it is automatacially adjusted when this method is called.
\item \textbf{bool cleanup()} \hfill \vskip 1pt
	This method is used to clean the knowledgebase by removing all the unnecessary branches i.e, branches that consists only of IGNORE as the status. This is an example for a method that can cause a change in the largest symbol. If only the branches contain a particular symbol and they are removed in the clean up, it subsequentely causes a change in the largest symbol. 
\end{enumerate}

\subsection{Iterators}
	It has been explained already that the knowledgebase uses the list of \integer as the type of words. When we consider query handling, we would require ``list of list of \integer'' to store them. The important part is that we need to iterate over these lists to process the words and queries. Hence we require the starting and ending point of the iteration. We use the following four simple methods that help us in this regard.
\begin{enumerate}
\item \textbf{iterator begin()} \hfill \vskip 1pt
	The method always returns the root node of the tree (epsilon).

\item \textbf{iterator end()} \hfill \vskip 1pt
	The method returns the end of the word or in other words, the end node. 
	 
\item \textbf{iterator qbegin()} \hfill \vskip 1pt
	This is the method used to get the query node at which the iterator needs to begin. That is, it begins at the first node which is marked as ``required''.
	
\item \textbf{iterator qend()} \hfill \vskip 1pt
	It returns the final node which is a query.
\end{enumerate}

\subsection{Displaying the knowledgebase}
In this section, we will discuss three methods that are used in relevance with displaying the knowledgebase.
\begin{enumerate}
\item \textbf{string tostring()} \hfill \vskip 1pt
It creates the \stringtype stream to be used by the ``print'' method.

\item \textbf{void print(ostream \&os)} \hfill \vskip 1pt
	This method is used to print the knowledgebase on screen. It prints the word, its status and the answer of all the words available in the knowledgebase.

\item \textbf{string generate\_dotfile()} \hfill \vskip 1pt
	The method creates a ``.dot'' file of the entire knowledgebase. This is the method which was made use of in the demo programs explained int he previous chapter. The file can be executed with the GraphViz tool to observe the graphical representation of the knowledgebase. 
\end {enumerate}

\subsection{Other Important Methods}
	The following methods offer features which may prove useful in using as well as extending \libalf.
\begin{enumerate}
\item \textbf{unsigned long long int get\_memory\_usage()} \hfill \vskip 1pt
	The method returns the memory used by the knowledgebase on the system. Using this method at some point could be a good way of deciding if cleanup() needs to be called or not. 

\item \textbf{bool recursive\_different(node * other, int depth)} \hfill \vskip 1pt
	The method is used to check the consistancy of two words. Two words are said to be consistant if they have the same answer. 
	
\item \textbf{bool merge\_knowledgebase(knowledgebase \& other\_tree)} \hfill \vskip 1pt
	This method is used to merge two different knowledgebases. In merging the same, it follows some protocols. In the first place, two knowledgebases can be merged only if they are consistant, i.e., if they have similar words and answers. If inconsistant, the method returns \false. Otherwise, the method moves on to merge them. However, the method merges only all the answered nodes from the two knolwedgebases. Queries do not get merged. 
\end{enumerate}

\subsection{Serialize and Deserialize}
	There are two other important methods that can be very useful when working with \libalf. We will describe the methods now and explain their purpose behind design.
\begin{enumerate}
\item \textbf{basic\_string$<$int32\_t$>$ serialize()} \hfill \vskip 1pt
	This method is used to convert the entire knowledgebase into a \stringtype. 
\item \textbf{bool deserialize(basic\_string$<$int32\_t$>$::iterator \&it, basic\_string$<$int32\_t$>$ ::iterator limit)} \hfill \vskip 1pt
	This method is used to convert the \stringtype that represents the knowledgebase into a tree-like structure.
\end{enumerate}	
	The main advantages of using these methods is that it offers portability. They allow the user to save their current work done with \libalf. By converting the tree into a single string, it allows the user to save the knowledgebase into the hard disk, share it over the internet, carry and use it another machine and so on. The deserialize method helps in converting back to the tree structure to put the \libalf into use.
	
\section{Methods Specifications}
\subsection{Nodes}
\begin{enumerate}
%%%
\item \begin{detail}
{get\_next}
{node* get\_next(node * current\_child)}
{current\_child - The current child}
{Returns the next node} 
\end{detail}
%%%
\item \begin{detail}
{Constructor}
{node(knowledgebase * base)}
{base - the name of the knowledgebase}
{Creates the root node of the knowledgebase and sets its \texttt{parent} to NULL} 
\end{detail}
%%%
\item \begin{detail}
{get\_parent}
{node * get\_parent()}
{--}
{Returns the parent of the node that calls this function} 
\end{detail}
%%%
\item \begin{detail}
{find\_child}
{node * find\_child(int label)}
{label - the label that the child node must contain}
{Returns the node that contains the label specified as the parameter} 
\end{detail}
%%%
\item \begin{detail}
{find\_descendant}
{node * find\_descendant(list$<$int$>$::iterator infix\_start,\\ list$<$int$>$::iterator infix\_limit)}
{infix\_start - the word or symbol that is the starting point \\ infix\_limit - the word which is to be found}
{Returns the node that represents the word infix\_limit} 
\end{detail}
%%%
\item \begin{detail}
{find\_or\_create\_child}
{node * find\_or\_create\_child(int label)}
{label - the label that the child node must contain}
{Returns the node that contains the label specified as parameter. If not found, it creates such a node and returns it.} 
\end{detail}
%%%
\item \begin{detail}
{serialize\_subtree}
{void serialize\_subtree(basic\_string$<$int32\_t$>$ \& into)}
{\texttt{into} - the string that contains the serialized trees of the knowledgebase}
{Converts the subtree into \stringtype and appended to \texttt{into}. This method is used during serialization} 
\end{detail}
%%%
\item \begin{detail}
{deserialize\_subtree**}
{bool deserialize\_subtree(basic\_string$<$int32\_t$>$::iterator \& it, \\ basic\_string$<$int32\_t$>$::iterator limit, int \& count)}
{
\texttt{it} - iterator to iterate over the string containing the word \\
\texttt{limit} - the last word that the subtree contains
\texttt{count} - \integer to count the subtrees
 }
{Returns \true after deserializing the subtrees. Returns \false if \texttt{it} and \texttt{limit} are equal.} 
\end{detail}
%%%
\item \begin{detail}
{get\_selfptr}
{node * get\_selfptr()}
{--}
{A self pointer that returns its own node.} 
\end{detail}
%%%
\item \begin{detail}
{max\_child\_count}
{int max\_child\_count()}
{--}
{Returns the maximum number of children existing in the knolwedgebase. If it returns ``n'', it implies that there may exist [0..n] suffixes.} 
\end{detail}
%%%
\item \begin{detail}
{has\_specific\_suffix}
{bool has\_specific\_suffix(answer specific\_answer)}
{\texttt{specific\_answer} - the answer that needs to be compared}
{Checks if a specific suffix/word has a specific answer. Returns \true if such a case exists, otherwise returns \false.} 
\end{detail}
%%%
\item \begin{detail}
{get\_label}
{int get\_label()}
{--}
{Returns the label of this node (which is the last symbol of the word that this node represents).} 
\end{detail}
%%%
\item \begin{detail}
{get\_word}
{list<int> get\_word()}
{--}
{Returns the word that this node represents.} 
\end{detail}
%%%
\item \begin{detail}
{mark\_required}
{bool mark\_required()}
{--}
{Returns \true if answer to this node is required. Returns \false if the answer is already known.} 
\end{detail}
%%%
\item \begin{detail}
{is\_required}
{bool is\_required()}
{--}
{Returns \true if this node is marked unknown and required, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{is\_answered}
{bool is\_answered()}
{--}
{Returns \true if this node is already answered, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{set\_answer}
{bool set\_answer(answer ans)}
{\texttt{ans} - answer that must be set.}
{Returns \true if the node is already answered and the answer is same as \texttt{ans}, otherwise \false. If the node is not answered already, then it returns \true after setting \texttt{ans} as the answer.} 
\end{detail}
%%%
\item \begin{detail}
{get\_answer}
{answer get\_answer()}
{--}
{Returns the answer of this node.} 
\end{detail}
%%%
\item \begin{detail}
{no\_subqueries}
{bool no\_subqueries(bool check\_self = true)}
{\texttt{check\_self} - Set to true. Used to check if the status of this node is marked required. }
{Returns \true if there are any queries with this node as the prefix, \false otherwise. Also returns \false if this node is not answered and marked required.} 
\end{detail}
%%%
\item \begin{detail}
{different}
{bool different(node * other)}
{\texttt{other} - a node whose answer needs to be compared to the current node. }
{Returns \true if this node and \texttt{other} node have the same answer, \false otherwise. } 
\end{detail}
%%%
\item \begin{detail}
{recursive\_different}
{bool recursive\_different(node * other, int depth)}
{\texttt{other} - a node whose answer needs to be compared to the current node.
 \texttt{depth} - the depth of the tree that indiciates the length of the word. }
{Compares the answers of the two nodes and their children upto a level specified by \texttt{depth}. Returns \true if there are no inconsistancies in the answers, \false otherwise. } 
\end{detail}
%%%
\item \begin{detail}
{is\_prefix\_of}
{bool is\_prefix\_of(node*other)}
{\texttt{other} - a node whose answer needs to be compared to the current node.}
{Retruns \true if this node is a suffix of the \texttt{other} node. } 
\end{detail}
%%%
\item \begin{detail}
{is\_suffix\_of}
{bool is\_suffix\_of(node*other)}
{\texttt{other} - a node whose answer needs to be compared to the current node.}
{Retruns \true if this node is a preffix of the \texttt{other} node. } 
\end{detail}
%%%
\item \begin{detail}
{get\_memory\_usage}
{unsigned long long int get\_memory\_usage()}
{--}
{Retruns the size of the memory used by this subtree. } 
\end{detail}
%%%
\item \begin{detail}
{ignore}
{void ignore()}
{--}
{Changes the status of this node to NODE\_IGNORE. } 
\end{detail}
%%%
\item \begin{detail}
{cleanup}
{bool cleanup()}
{--}
{Returns \true after deleting all the branches that has status as NODE\_IGNORE. } 
\end{detail}
%%%
\end{enumerate}

\subsection{Iterator}
\begin{enumerate}
\item \begin{detail}
{iterator}
{iterator()}
{--}
{Sets this node to NULL and initializes an iterator to the last node that is marked required. } 
\end{detail}
%%%
\item \begin{detail}
{iterator}
{iterator(const iterator \& other)}
{--}
{Sets the values of this node to those of the \texttt{other} node.} 
\end{detail}
%%%
\item \begin{detail}
{iterator**}
{iterator(bool queries\_only, typename list$<$node*$>$::iterator currentquery, node * current, knowledgebase * base)}
{\texttt{queries\_only} - a boolean variable that is \true if queries exist and \false if there are no queries in the knowledebase
 \texttt{currentquery} - iterator to iterate over queries
 \texttt{current} - the node under consideration
 \texttt{base} - the knowledgebase that is being processed.}
{Sets the values of this node to those specified in the arguement.} 
\end{detail}
%%%
\item \begin{detail}
{operator++}
{iterator \& operator++()}
{--}
{Operator overloading applied to ``++''. Creates an iterator that points to the next query and returns the node} 
\end{detail}
%%%
\item \begin{detail}
{operator++ **}
{iterator operator++(int foo)}
{--}
{--} 
\end{detail}
%%%
\item \begin{detail}
{is\_valid()}
{bool is\_valid()}
{--}
{Returns \true if the current iterator is not NULL, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{operator*}
{node \& operator*()}
{--}
{Returns the pointer to the current iterator.} 
\end{detail}
%%%
\item \begin{detail}
{operator-$>$}
{node * operator-$>$()}
{--}
{Returns the current iterator.} 
\end{detail}
%%%
\item \begin{detail}
{operator=}
{iterator \& operator=(const iterator \& it)}
{\texttt{it} - an iterator}
{Creates an iterator with the values of iterator \texttt{it} and returns this. } 
\end{detail}
%%%
\item \begin{detail}
{operator==}
{bool operator==(const iterator \& it)}
{\texttt{it} - an iterator}
{Returns \true if the current iterator is same as \texttt{it}, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{operator!=}
{bool operator!=(const iterator \& it)}
{\texttt{it} - an iterator}
{Returns \true if the current iterator is not equal to \texttt{it}, \false otherwise.} 
\end{detail}
\end{enumerate}



\subsection{Knowledgebase}
\begin{enumerate}
%%%
\item \begin{detail}
{knowledgebase}
{knowledgebase()}
{--}
{Creates a knowledgebase with root as NULL.} 
\end{detail}
%%%
\item \begin{detail}
{knowledgebase}
{\~knowledgebase()}
{--}
{Deletes the knowledgebase by deleting the root.} 
\end{detail}
%%%
\item \begin{detail}
{clear}
{void clear()}
{--}
{Deletes the existing knowledgebase and creates a new knowledgebase containing only the root.} 
\end{detail}
%%%
\item \begin{detail}
{clear\_queries}
{void clear\_queries()}
{--}
{Deletes all the nodes that are marked as queries.} 
\end{detail}
%%%
\item \begin{detail}
{undo**}
{bool undo(unsigned int count)}
{\texttt{count} - }
{Used to undo the last operation.} 
\end{detail}
%%%
\item \begin{detail}
{get\_memory\_usage}
{unsigned long long int get\_memory\_usage()}
{--}
{Returns the memory used by the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{is\_answered}
{bool is\_answered()}
{--}
{Returns \true if there are no nodes marked required, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{is\_empty}
{bool is\_empty()}
{--}
{Returns \true if there are no nodes marked required and answered (the tree is empty), \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{count\_nodes}
{int count\_nodes()}
{--}
{Returns the number of nodes present in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{count\_answers}
{int count\_answers()}
{--}
{Returns the number of nodes that are already answered in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{count\_queries}
{int count\_queries()}
{--}
{Returns the number of nodes that are marked required in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{count\_resolved\_queries}
{int count\_resolved\_queries()}
{--}
{Returns the number of answered nodes that were once marked required.} 
\end{detail}
%%%
\item \begin{detail}
{reset\_resolved\_queries}
{void reset\_resolved\_queries()}
{--}
{Resets the number of resolved queries to zero.} 
\end{detail}
%%%
\item \begin{detail}
{get\_largest\_symbol}
{int get\_largest\_symbol()}
{--}
{Returns the largest symbol that is present in the knowledgebase. Essentially, this returns the number which is one less than the alphabet size.} 
\end{detail}
%%%
\item \begin{detail}
{check\_largest\_symbol}
{int check\_largest\_symbol()}
{--}
{Adjusts the largest symbol present in the knowledgebase and returns it.} 
\end{detail}
%%%
\item \begin{detail}
{print}
{void print(ostream \&os)}
{\texttt{os} - an output stream.}
{Prints the knowledgebase on the screen. Prints the word, status and the answer of all the words stored in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{tostring}
{string tostring()}
{--}
{Used to return a string stream for serialization.} 
\end{detail}
%%%
\item \begin{detail}
{generate\_dotfile}
{string generate\_dotfile()}
{--}
{Generates the ``.dot'' file of the knowledgebase for graphical representation.} 
\end{detail}
%%%
\item \begin{detail}
{serialize}
{basic\_string$<$int32\_t$>$ serialize()}
{--}
{Returns a string which represents the complete knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{deserialize**}
{bool deserialize(basic\_string$<$int32\_t$>$::iterator \&it, \\ basic\_string$<$int32\_t$>$::iterator limit)}
{\texttt{it} - iterator to iterate over the string containing the word.
 \texttt{limit} - iterator that points to the last word }
{Returns \true if the string was deserialized to knowledgebase successfully, \false if the deserialization failed.} 
\end{detail}
%%%
\item \begin{detail}
{deserialize\_query\_acceptances}
{bool deserialize\_query\_acceptances(basic\_string$<$int32\_t$>$::iterator \&it,\\ basic\_string$<$int32\_t$>$::iterator limit)}
{\texttt{it} - iterator to iterate over the string containing the word.
 \texttt{limit} - iterator that points to the last word }
{Returns \true after answering all the queries in the knowledgebase from a single serialized data. } 
\end{detail}
%%%
\item \begin{detail}
{create\_query\_tree}
{knowledgebase * create\_query\_tree()}
{--}
{Returns a tree created by adding to this tree, all the words marked as required in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{get\_queries}
{list$<$list$<$int$>$ $>$ get\_queries()}
{--}
{Returns a list of list of \integer that consists of all the queries existing in the knowledgebase.} 
\end{detail}
%%%
\item \begin{detail}
{merge\_knowledgebase}
{bool merge\_knowledgebase(knowledgebase \& other\_tree)}
{\texttt{other\_tree} - the tree to be merged.}
{Returns \true if the current tree could be merged with the \texttt{other\_tree}, \false otherwise. Two trees can be merged only if they are consistant. This method merges only answered information, it does not merge the queries. } 
\end{detail}
%%%
\item \begin{detail}
{add\_knowledge}
{bool add\_knowledge(list$<$int$>$ \& word, answer acceptance)}
{\texttt{word} - the word to be added to the knowledgebase.
 \texttt{acceptance} - the classification of the word.}
{Returns \true if the knowledge for this word does not already exist and is successfully added to the knowledgebase, \false otherwise.} 
\end{detail}
%%%
\item \begin{detail}
{add\_query}
{int add\_query(list$<$int$>$ \& word, int prefix\_count = 0)}
{\texttt{word} - the word/query to be added to the knowledgebase.
 \texttt{prefix\_count} - initialized to zero. It is the count of all the prefixes that can be formed with the word.}
{Creates the query and the necessary prefixes (which will also be marked as a query) and returns the total number of queries formed.} 
\end{detail}
%%%
\item \begin{detail}
{resolve\_query}
{bool resolve\_query(list$<$int$>$ \& word, answer \& acceptance)}
{\texttt{word} - the word/query to be added to the knowledgebase.
 \texttt{acceptance} - the classification of the word.}
{If the word is already known and is answered, then the answer is assigned to \texttt{acceptance} and returns \true, otherwise returns \false.} 
\end{detail}
%%%
\item \begin{detail}
{resolve\_or\_add\_query}
{bool resolve\_or\_add\_query(list$<$int$>$ \& word, answer \& acceptance)}
{\texttt{word} - the word/query to be added to the knowledgebase.
 \texttt{acceptance} - the classification of the word.}
{Returns \true if the word is already known and answered, else marks the word as required and returns \false.} 
\end{detail}
%%%
\item \begin{detail}
{get\_nodeptr}
{node* get\_nodeptr(list$<$int$>$ \& word)}
{\texttt{word} - a word.}
{Returns the node that represents this word.} 
\end{detail}
%%%
\item \begin{detail}
{get\_rootptr}
{node* get\_rootptr()}
{--}
{Returns the root.} 
\end{detail}
%%%
\item \begin{detail}
{begin}
{iterator begin()}
{--}
{Returns an iterator that begins at the root node.} 
\end{detail}
%%%
\item \begin{detail}
{end}
{iterator end()}
{--}
{Returns an iterator which is used to point to the last node.} 
\end{detail}
%%%
\item \begin{detail}
{qbegin}
{iterator qbegin()}
{--}
{Returns an iterator that begins at the first node that is marked required.} 
\end{detail}
%%%
\item \begin{detail}
{qend}
{iterator qend()}
{--}
{Returns an iterator which is used to point to the last node that is marked required.} 
\end{detail}
\end{enumerate}

\textbf{methods not described} \vskip 1pt
bool is\_lex\_smaller(node * other) \\
bool is\_graded\_lex\_smaller(node * other) \\
unsigned int get\_timestamp() \\
string generate\_dotfile(equivalence\_relation \& eq) \\
equivalence relation class\\
class kIterator\_lex\_graded 