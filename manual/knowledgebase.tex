\chapter{The Knowledgebase}

The knowledgebase is the central repository of information. It is a database that stores words and their classification. Apart from this basic functionality, the knowledgebase also offers number of other features thereby increasing extensibility support. 
But we have not designed our knowledgebase to do just that but also to provide extensibility. In this regard, the methods used implementation of knowledgebase can be divided into two categories - \textbf{\emph{Methods important for Using \libalf}} and \textbf{\emph{Methods important for expanding \libalf}}. 
\paragraph{}
In this chapter, we shall discuss the knowledgebase from a user's perspective and a developer's perspective. The material will include adequate account of its structure, operations and implementation.  The final section of this chapter will provide an appendix of all the methods used in programming the knowledgebase with a brief description corresponding to it.  

(A PICTURE OF KNOWLEDGEBASE FROM DEMO HERE)

\section{The knowledgebase - A User's Perspective}

\paragraph{} In this section, we describe the basic functionality of the knowledgebase. The following material provides fundamental information that one would have to know to employ \libalf in an application. This section will not deal with explanation of the internal structure or methods used for operations of the knowledgebase. However, it will provide some elementary details of methods that could be required to better understand an operation.  To discover more on those areas, you may refer the section on Developer's Perspective and Methods in Detail.

\subsection*{Basic Concepts}
	
	To understand the functions of the knowledgebase, it is important to know the basic underlying concepts. We shall define some key terms for a start.
	
\paragraph{Symbol} It is an arbitrary data which has some meaning to or effect on the machine. It is elementary data on which an automaton is built. 

\paragraph{Alphabet} It is a finite set of symbols. An alphabet set is usually denoted by $\Sigma$.
\vskip 1pt
\[
\sum = \{0,1,\ldots\}
\]

For example, in \libalf, when alphabet size of two is specified by the user, then by default the alphabets involved in the automaton would be 
\[
\sum = \{0,1\}
\]

This leads us to define the following.

\paragraph{Word} A finite string formed by the concatenation of a number of symbols.

\paragraph{Language} Language is a set of words, formed by symbols in a given alphabet.

Thus, adding to our previous example, ``01101'' would be a word from the given set of alphabet and the set \{ 01101, 11011\} would be a Language.

\subsection*{Storing Words} 
The knowledgebase of \libalf is an efficient storage of words and their classifications. Classifications are nothing but the acceptance rules of the word i.e., whether the word has to be accepted or rejected by the automaton. The knowledgebase maintains information about this with the variable \texttt{status}. Since the knowledgebase can use arbitrary values, one may choose to store this information in any form. 

\subsection*{Queries and Answers} 
The next major function of the knowledgebase would be to store queries to help the learning algorithm build the automaton. As mentioned in the previous chapter, a query is nothing but a word whose classification is unknown and needs to be retrieved from the user or teacher. This is called the answer. Hence, given a set of words and classifications, the knowledgebase can store them and when a learning algorithm processes these words, queries created that are also stored in the knowledgebase (which are later presented to the user).

\subsection*{Other features} 
Apart from the essential functions, the knowledgebase also provides certain features that can be made us of when employing it in an application. The knowledge available in the knowledgebase can be also be serialized into the user's hard disk. Also, the knolwedgebase allows one to generate a dot file of the knowledge available to have a graphical representation of the same. All the more, the knowledgebase can also be merged with another knowledgebase without introducing any errors. These features are elaborated in forthcoming sections.

\section{Structure of the Knowledgbase - A Developer Perspective}

\subsection{Representation of a word in the Knowledgebase}
\paragraph{}
	Ideally, the first step towards understanding the organization of the knowledgebase would be to realize how a word is represented in it.
\paragraph{}
	Generally, the knowledgebase can be described as a tree structure with nodes representing the words. More precisely, it is a prefix tree. Given this description and the demo programs from the website (which even presents a graphical representation of the tree), one would imagine a word \texttt{01101} in the knowledgebase as a tree with a node that holding a \stringtype or \texttt{list of integers} with value ``01101''. However, this is \textbf{NOT} how knowledgebase is implemented in \libalf.
\paragraph{}
	The node by itself does \emph{not} contain the complete word, but only contains the i\textsuperscript{th} symbol of the word. An example can make things clear. 
\paragraph{}	
	Consider a word \texttt{01101}. When this word is added to the knowledgebase, it is not stored as a single \stringtype at a node of the tree, instead the sequence of the symbols that comprise the word construct the branch of the tree with every node representing exactly one symbol. This implies, to represent this word in the knowledgebase, the root (which is always an empty string represented by Epsilon) creates a child node that represtents ``0''. The next symbole of the word ``1'' is now represented in a node which is the child of the node representing its previous symbol ( or the parent node), ``0''. Thus, one can reach the node representing the word \texttt{01101} by following the 0\textsuperscript{th} child of the root node, then further accessing the first child of this node and so on.
\paragraph{}
	Hence, to retrive a word from the tree, one has to traverse down from the root node to the final child node by accumulating the symbols that every node represents. Alternatively, one can also recover the word by ascending from a node to the root and reversing the word obtained. \libalf uses the latter technique. 
	\vskip 1pt

	(A PICTURE OF THE ABOVE EXPLAINED TREE HERE)	
	
\subsection{Description of the Structure}
	
	The knowledgebase is designed as a template class enabling usage of arbitrary values for storing desired information.
	The knowledgebase class contains the node class which describes the variables that are necessary for the node. This class also contains some of the internal methods which are important for both using and expanding \libalf.
	The constructor of the node class creates the tree, more precisely (a root node) with the following variables that define the node.
	\begin{itemize}
	\item \texttt{parent} \hfill \vskip 1pt A variable of type \node that points to the parent of the node.
	\item \texttt{label} \hfill \vskip 1pt An \integer variable that contains the alphabet that the node represents. (-1 for root node)
	\item \texttt{status} \hfill \vskip 1pt This indicates whether the classification of the word (the word is constructed by traversing through the tree) is required, answered or can be ignored. It is an \texttt{enum} type variable with the respective three values ``NODE\_IGNORE'', ``NODE\_REQUIRED'' and ``NODE\_ANSWERED''. 
	\item \texttt{answer} \hfill \vskip 1pt It is the type of the template class used in the constructing the knowledgbease. 
	\end{itemize}
	
	After constructing the root node, the child nodes are created with the \vectored type \node variable called \texttt{children}. 
	The knowledgebase contains methods that act upon the node for the operations. 
	These variables and methods form the building blocks of knowledgebase. The methods employed in the knowledgebase is described in the next section.

\section{Methods in Detail}

	In this section we will discuss the methods used in the knowledgebase. The description given below pertains more to a developer as it offers greater insight into the workflow of the knowledgebase along with particulars of the methods.
	
\subsection{Nodes}
	
	Having drawn the working of a node, we begin describing some of the functions that concerns the node. These are internal methods and they perform some basic operations as discussed below.
\begin{enumerate}
\item \textbf{node* get\_next(node * current\_child)} \hfill \vskip 1pt
	This function returns the next node or the next child of the current node (which is passed as an arguement). 
	
\item \textbf{node * get\_parent()} \hfill \vskip 1pt
	The method returns the parent of the node under use.

\item \textbf{list$<$int$>$ get\_word()} \hfill \vskip 1pt
	This function returns the word that the current node represents. The method traverses backwards in the tree (ascending from child to parent) and reverses the sequence obtained to build the correct word.
	
\item \textbf{int get\_label()} \hfill \vskip 1pt
	This function returns the label that the node represents.
	
\item \textbf{node * find\_child(int label)} \hfill \vskip 1pt
	The function is used to find the child node with the specified label.
	
\item \textbf{node * find\_descendant(list$<$int$>$ :: iterator infix\_start, list<int>::iterator infix\_limit)} \hfill \vskip 1pt
	This function is used to find the child node specified by a word. It traverses through the tree based on the iteration over the word to find the path that generates the required word.
	
\end{enumerate}

\subsection{Words and Classification}

	In principal, the primary purpose of the knowledgebase is to store the words and classifications that constitutes the base for the learning algorithm to compute an automaton. We discuss the following two functions of the node and a method relating to this important aspect.
\begin{enumerate}
\item \textbf{node * find\_or\_create\_child(int label)} \hfill \vskip 1pt
	This function returns the child node given the label. However, if the node does not exist, it creates the child node with the specified label.
	
\item \textbf{node * find\_or\_create\_descendant(list$<$int$>$::iterator infix\_start, list$<$int$>$::iterator infix\_limit)} \hfill \vskip 1pt
	This function behaves almost similar to the previous one. However, the difference being, it does not operate with a single label but on a word (which is a list of \integer). 
	
\item \textbf{bool add\_knowledge(list$<$int$>$ \& word, answer acceptance)} \hfill \vskip 1pt
	This is the key function that adds information to the knowledgebase. The parameter ``word'' represents the sample word and ``acceptance'' represents the classification of the word. 
	This method simply calls the ``find\_or\_create\_descendant(list$<$int$>$::iterator infix\_start, list$<$int$>$::iterator infix\_limit)'' so that the knowledge will be added only information about the word does not already exist in the knowledgebase.
\end{enumerate}	

\subsection{Queries}

	The next point of discussion would be the part of knowledgebase that handles queries. For instance, an online algorithm produces queries at every ``advance'' of the algorithm. These queries are stored in the knowledgebase and are later presented to the user for classification.
\paragraph{}
	To understand the implementation of query handling in \libalf's knowledgebase, one must first know the functionality of three methods that are crucial for query handling.

\begin{enumerate}
\item \textbf{bool mark\_required()} \hfill \vskip 1pt
	The method returns a boolean value \true if the acceptance or the classification of the node is requried (i.e, ``status'' is NODE\_REQUIRED) or \false if the classification is already known.
	
\item \textbf{bool is\_required()} \hfill \vskip 1pt
	The method returns the ``status'' as \texttt{NODE\_REQUIRED}. It is used to set this status to a particular node under consideration.

\item \textbf{bool is\_answered()} \hfill \vskip 1pt
	The method returns the ``status'' as \texttt{NODE\_ANSWERED}. It is used to set this status to a particular node under consideration.
\end{enumerate}

\vskip 1pt
  The following methods describe the operations associated with queries.

\begin{enumerate}
\item \textbf{knowledgebase * create\_query\_tree()} \hfill vskip 1pt
	The method creates a tree containing the queries to be answered. Therefore, its return type is \texttt{knowledgebase}.
It uses the \texttt{get\_word()} method to retrive the word and uses the \texttt{add\_query()} method add it in the tree.

\item \textbf{int add\_query(list$<$int$>$ \& word, int prefix\_count = 0)} \hfill \vskip 1pt
	The method is primarily used to add the word into the query tree. When the classification of a word has to be known, the method firsst checks if the word already exists with its classification in the knowledgebase (by using the \texttt{find\_or\_create\_child(int label)} method). Hence, if the classification of the word is unknown and does not already exist, the corresponding node will be created and eventually added in the query tree (since this method is used by \texttt{create\_query\_tree(\ldots)}.
  
\item \textbf{list$<$list$<$int$>$$>$ get\_queries()} \hfill \vskip 1pt
	This method returns the list of all the queries present in the knowledgebase (i.e, all words yet to classified). Naturally, the method uses the \texttt{get\_word()} function to build the word.
	
\item \textbf{bool resolve\_query(list$<$int$>$ \& word, answer \& acceptance) and bool resolve\_or\_add\_query(list$<$int$>$ \& word, answer \& acceptance)} \hfill \vskip 1pt
	These two methods can be described together as their functionality is almost similar and differ only in one aspect. Both methods return \true if the classification of the word is already known and \false if it is unknown. While ``resolve\_query()'' only returns \false, ``resolve\_or\_add\_query()'' marks the status of this word as required and then returns \false. Naturally, the former uses ``find\_descendant()'' and the latter makes use of ``find\_or\_create\_descendant()''.

\item \textbf{void clear\_queries()} \hfill \vskip 1pt
	This method is used to remove all the nodes that are identified or marked as a query.
\end{enumerate}
\vskip 1pt
\vskip 1pt
\subsection{Alphabets in Knowledgebase}
	Although we have defined the basic concepts that includes alphabets in this chapter, the knowledgebase does not really store the alphabet size of the automaton specified by the user. The knowledgebase does not construt the tree based on the alphabet size specified by the user and is capable of constructing the tree precisely even if symbols outside the alphabet set are fed in the input (which includes the extra symbols). But, such improper input will lead to the learning algorithm computing a conjecture which might not be the expectation of the user.
	However, the knowledgebase can at any point of time identify and operate on the alphabet size. This can be regarded as the largest symbol that is processed in the knowledgebase. From Section --, we know that for an alphabet size of 2, the largest symbol would be ``1''.
One can use the following two methods available.
\begin{enumerate}
\item \textbf{get largest symbol} \hfill \vskip 1pt
	(Text to be added here)
\item \textbf{check largest symbol} \hfill \vskip 1pt
	(Text to be added here)
\end{enumerate}



Other Important Methods yet to be used in the document

\paragraph{get memory usage}
\paragraph{to string}
\paragraph{print} ?
\paragraph{generate dot file}
\paragraph{merge knowledgebase}
\paragraph{get root ptr}
\paragraph{get node ptr}


Serialize and deserialize

Iterator
begin, qbegin, end, qend

Iterator class!

\textbf{iterator qbegin()}
	This is the method used to get the query node at which the iterator needs to begin. 




