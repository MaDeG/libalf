\chapter{\jalf Java Library}

The \jalf \java library, as you may have come across in various sections in the previous chapters, is the \java implementation of \libalf. Hence, the \jalf is not a standalone library and indeed requires the \libalf library to be useful. The \jalf library can be used through JNI calls or by using a dispatcher to the \cpp \libalf itself. This implies that \libalf library is indeed necessary to use \jalf \java library. 

\section{Files Structure}
The \jalf implementation can be found in \texttt{/libalf/jalf} folder of the \libalf package. The \jalf package information is as follows.
\begin{itemize}
 \item \texttt{src} - The folder contains the JNI call methods that forwards the method calls to \cpp part.
 \item \texttt{include} - The header files for the above.
 \item \texttt{java/src/de/libalf} - The files available in this folder are the interfaces to the native methods.
 \item \texttt{java/src/de/libalf/jni} - The java native methods of all the components.
\end{itemize}

\section{Naming Conventions}
The JNI calls of the source files are named as follows. \\
\textbf{Java\_de\_libalf\_jni\_JNI[ClassName]\_name\_1of\_1the\_1method( \emph{parameters} )} \\
The parameters consist of the JNI Environment variable, the java object and the parameters of the original method along with a pointer to the object of this method. For example, the method \texttt{void resolve\_or\_add\_query} from the \cpp part of knowledgebase is written as \\
\textbf{Java\_de\_libalf\_jni\_JNIKnowledgebase\_resolve\_1or\_1add\_1query(JNIEnv *env, jobject obj, jintArray word, jlong pointer)} \\
Here, \emph{env} is the JNI environment variable,  \emph{obj} is the jobject, \emph{word} represents the knowledge to be either resolved or added to the knowledgebase, pointer is the pointer to the \cpp object. The native java files consist of the same method names as the \cpp counterpart except that.

\section{Structure of \jalf}

\subsection*{Data Structures}
The data structure used in \jalf is similar to that as \libalf.  In \libalf, words were represented as list of integers. Similarly \jalf uses integer arrays to represent the words. To represent a list of words, \jalf uses the data structure LinkedList.
An important difference lies in the data structure of the knowledgebase. While it is possible to store arbitrary value types for classification in \libalf, \jalf uses a boolean type for the knowledgebase and hence only boolean values (\true or \false) can be used for storing classification information in \jalf. 

\subsection*{The Factory Class}
From an abstract view, the components are created in \jalf under a roof called Factory. That is, the objects of all components are created in an abstract class called as \texttt{factory}. 

\begin{lstlisting}
int[] words
boolean classification;
LibALFFactory factory = JNIFactory.STATIC;
alphabetsize = get_AlphabetSize();

//Factory created
Knowledgebase base = factory.createKnowledgebase();

/* Code to add knowledge to knowledgebase here */

LearningAlgorithm algorithm = factory.createLearningAlgorithm(
				Algorithm.RPNI, base, alphabetsize);
//The algorithm is advanced
BasicAutomaton automaton = (BasicAutomaton) algorithm.advance();

//Output displayed
make_OutputFile(automaton.toDot());

\end{lstlisting}






In essence, the factory interface initializes or creates the knowledgebase, learning algorithm, logger and normalizer.

\section{Working with \jalf - Preliminaries}

\subsection*{JNIObject}
The \texttt{JNIObject} is the root of all classes representing the JNI \libalf \cpp objects. Each JNIObject stores a 64 bit pointer variable that points to memory location of the \cpp object. This ensures memory access is allowed on both 32 and 64 bit systems. Each \texttt{native} method call on \cpp objects via the JNI interface has to provide a pointer to locate the object. This class is not initialized but its subclasses provide an \texttt{init} method to initialize a \cpp object via the JNI interface and returns the memory address of the object. For instance, the native method \texttt{private native long init()} of the knowledgebase invokes the JNI interface to initialize a new \cpp knowledgebase object without any parameters and returns the pointer to this object. \\
The \texttt{JNIObject} extends \texttt{LibALFObject} which is the interface that initializes the factory and creates pointer to the \cpp objects. 
   
\subsection*{JNItools}
The \texttt{jni\_tools} provide methods useful especially for converting variables to JNI data structures. The methods provided are as follows.
\begin{itemize}
 \item \textbf{jintArray basic\_string2jintArray\_tohl(JNIEnv *env, basic\_string$<$int32\_t$>$ str)}
 \item \textbf{jintArray basic\_string2jintArray(JNIEnv *env, basic\_string$<$int32\_t$>$ str)} \\ 
	To convert basic\_string to jintArray. 
 \item \textbf{jintArray list\_int2jintArray(JNIEnv *env, list$<$int$>$ l)} \\
	The method converts list of integers to jintArray.
 \item \textbf{jobject create\_transition(JNIEnv* env, int source, int label, int destination)} \\
	The method creates an edge between the source node and the destination node with the prescribed label.
 \item \textbf{jobject convertAutomaton(JNIEnv* env, bool is\_dfa, int alphabet\_size, int state\_count, set$<$int$>$ \& initial, set$<$int$>$ \& final, multimap$<$pair$<$int, int$>$, int$>$ \& transitions)}\\ ??
\end{itemize}

\subsection*{Exceptions}
The classes \texttt{ALFException} and \texttt{ALFObjectDestroyedException} are used by the components for throwing exceptions of any kind. One particular example is from a class \texttt{JNILearningAlgorithmOffline}. The class consists of a method that throws an exception when tried to invoke \texttt{add\_counterexample(int[] counterexample)} method with a message stating that \offline learning algorithms do not support adding counterexample.



\section{Automaton Tools}
Three classes that are important for working with the automaton is described below.

\subsection*{Basic Automaton}
The BasicAutomaton class represents a deterministic or nondeterministic finite automaton as it is generated by the LibALF library.
The automaton essentially consists of the set of \emph{states} which is represented by \integer between \texttt{0} and \texttt{numberOfStates} that work over an Alphabet set, set of \emph{initial states} and \emph{final states}. This class only stores the automaton but does not provide any functionality. 

\subsection*{BasicTransition}
Creates a new transition from source to destination, given the label of this transition.

\section{The Knowledgebase}
As mentioned earlier, \jalf can use only boolean variables for storing the classification. 
Like in the \cpp counterpart, the acceptance information or the classification of the word is from the \texttt{enum} variable {Accept, reject, dontcare or unknown}

\subsection{Loggers}
The functionality and the implementation of the logger is the same as in \libalf except a few differences. \jalf does not support IO logger. Which means that you can only choose to use the buffered logger (which logs the events as a \stringtype) or ignore it.
Also, the loglevel is converted to integer form (1 - ERROR, 2 - WARN, 3 - INFO and 4 - DEBUG) for processing. This is done in the method \\ \texttt{private int mapJNILoggerLevel(LoggerLevel logLevel)}. 

